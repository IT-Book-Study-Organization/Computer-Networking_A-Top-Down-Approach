## 3.5 연결 지향 전송: TCP
- TCP는 인터넷의 전송 계층에서 연결 지향적으로 신뢰할 수 있는 전송 프로토콜임.
- 이번장에서는 TCP가 신뢰할 수 있는 데이터 전송을 제공하기 위해 오류 감지, 재전송, 누적 확인, 타이머, 순서 및 확인 번호를 위한 헤더필요를 어떻게 확인하는지 알아봄

### 3.5.1 TCP 연결
- TCP는 연결 지향적 프로토콜로, 데이터 전송 이전에 두 프로세스 간에 "핸드세이크"가 필요
- 이 과정에서 초기 세그먼트를 주고받아 데이터 전송의 매개변수를 설정함
- 클라이언트와 서버 양쪽에서 TCP 상태 변수를 초기화함
- TCP 연결은 논리적인 것으로 두 끝 시스템의 TCP에만 공통 상태가 존재
- TCP는 전이 중 서비스로 한 호스트의 프로세스 A와 다른 호스트의 프로세스 B간에 TCP 연결이 존재한다면, 애플리케이션 계층 데이터는 A->B, B->A 이렇게 양방향 가능
- 근데 TCP는 단일 송신자와 수신자 간에만 이루어짐
- 클라이언트가 TCP 세그먼트를 전송 -> 서비가 두 번째 특별한 TCP 세그먼트로 응답 -> 클라이언트가 세 번째 특별한 세그먼트로 응답 이 과정을 handshake라고 함
- 첫번째와 두번째 세그먼트는 페이로드를 포함하지 않으며 애플리케이션 계층 데이터도 없음. 세번째는 페이로드 포함 가능
- 다시말해 두 호스트간에 세 개의 세그먼트가 전송되기 때문에 3-way handshake 라고함!
- ![image](https://github.com/user-attachments/assets/700f5923-63cc-45ed-be21-7ae685bf1d71)
- 클라이언트 프로세스에서 서버 프로세스로 데이터를 전송한다고 가정하자.
  - 1) 클라이언트 프로세스가 소켓을 통해 데이트 스트림을 전달
    2) 데이터가 소켓을 통과하면 송신 버퍼로 전송함(3-way handshake 중에 설정된 버퍼임)
    3) 여기서 가져와서 세그먼트에 배치할 수 있는 최대 데이터 양은 최대 세그먼트 크기(MSS)로 제한함.
    4) MSS는 로컬 송신 호스트가 전송할 수 있는 최대 링크 계층 프레임의 길이(MTU)를 결정한 후 TCP 세그먼트와 TCP/IP 헤더길이(40 바이트)가 단일 계층 프레임에 들어갈수 있도록 MSS를 설정함.
       이를테면 MTU는 1500 바이트 이고 MSS의 일반적인 값은 1460 바이트임
       ![image](https://github.com/user-attachments/assets/6aaa9b49-aa91-431f-9526-fbad726ca871)

    5) TCP는 클라이언트 데이터의 각 청크에 TCP 헤더를 쌍으로 묶어서 TCP 세그먼트를 형성함.
    6) 네트워크 계층으로 가서 IP 데이터그램에 의해서 캡슐화됨 그런 후 IP 다이어그램은 네트워크로 전송됨.
    7) 반대로 TCP가 반대편에서 세그먼트를 수신하면, 세그먼트의 데이터는 TCP 연결의 수신 버퍼에 저장됨
    8) 애플리케이션 이 버퍼에서 데이터 스트림을 읽게됨.
   
 ### 3.5.2 TCP 세그먼트 구조 
 - TCP 세그먼트는 헤더 필드와 데이터 필드
 - MSS는 세그먼트 데이터 필드의 최대 크기를 제한함
 - 이를테면 TCP 같은 이미지와 같은 큰 파일을 전송, 일반적으로 파일을 MSS 크기의 청크로 나누어 전송함.
 - TCP 세그먼트의 구조는 다음과 같다.
   - 소스 및 목적지 포트 버놓
   - 체크섬 필드
   - 32비트 시퀸스 번호 필드 및 32비트 확인 응답 번호 필드
   - 16비트 수신 창 필드
   - 4비트 헤더 길이 필드
   - 옵션 필드
   - 플래그 필드
     
   ![image](https://github.com/user-attachments/assets/995e88f3-adf6-435f-805e-e915c491bcbf)

#### 시퀸스 번호와 확인 응답 번호
##### 시퀸스 번호 필드 
- TCP 세그먼트에서 가장 중요한 두 가지 필드는 시퀸스 번호 필드와 응답 번호 필드임.
- TCP는 데이터가 비구조적이지만 순서가 있는 바이트 스트림으로 봄. 시퀸스 번호의 사용은 이 바이트 스트림에 대한 것이고 전송된 세그먼트의 시리즈에 관한건 아님
- ![image](https://github.com/user-attachments/assets/4fc2036d-90c6-41b2-af8b-9db61e2fd0f3)
- 이를테면 호스트 A의 프로세스가 호스트 B의 프로세스에 TCP 연결을 통해 데이터를 전송하려고 한다고 가정하였을 때, 호스트 A의 TCP는 데이터 스트림의 각 바이트에 암묵적으로 번호를 매김.
- 데이터 스트림이 500,000 바이트로 구성, MSS 1,000 바이트이며, 데이터 스트림의 첫 바이트가 0번으로 번호가 매겨진다고 가정함
- TCP는 500개의 세그먼트를 구성하게 됨(500 * 1,000) 이때의 각 시퀸스 번호는 TCP 세그먼트의 헤더에 들어감
  
##### 확인 응답 번호 
- 시퀸스 번호보다 약간 더 복잡함. TCP는 전이중 방식이므로 호스트 A는 호스트 B로부터 데이터를 수신하는 동시에 호스트 B에게 데이터 전송 가능
- 호스트 B로부터 호스트 A로 데이터가 전송함(호스트 B는 여러 개읭 데이터를 작은 조각으로 나눠서 호스트 A에게 보냄)
- B가 A에게 보낸 첫 번째 세그먼트를 번호가 내겨짐
- A는 B로부터 "0번 데이터", "1번 데이터", "2번 데이터"
- A는 B에게 "다음에 나는 3번 데이터를 기대하고 있어!" 라고 보냄. 그래도 A는 자신의 B에게 보냅니다.

##### Telnet: 시퀸스 번호와 확인 응답 번호의 사례 연구
- Telnet 세션 시작
  - 호스트 A가 호스트 B와 Telnet 세션을 시작함. 호스트 A는 클라이언트, 호스트 B는 서버로 라벨이 붙음
  - 클라이언트에게 사용자가 입력한 각 문자는 원격 호스트로 전송됨 -> 원격 호스트는 각 문자의 복사본을 다시 보내 클라이언트의 화면에 표시함
  - "에코 백" 기능은 Telnet 사용자가 보는 문자가 원격 사이트에서 이미 수신되었음을 보장함.
  - 그래서 사용자가 키를 누른 시점부터 문자가 모니터에 표시되기까지 데이터가 네트워크를 두 번 이동함

- 문자 입력 예시
  - 사용자 "C" 라는 문자를 입력하고 커피를 마신다고 가정하자. 클라이언트와 서버간의 TCP 세그먼트를 살펴보겠습니다.
  - 초기 시퀸스 번호는 클라이언트가 42, 서버가 79로 설정되어있을 때, 시퀸스 번호는 세그먼트 데이터 필드 첫 번째 바이트 번호임. 따라서 클라이언트가 보내는 첫 번째 세그먼트는 42번 시퀸스 번호를 가짐. 서버가 보내는 세그먼트는 79번 시퀸스 번호를 가짐
  - TCP 연결이 되고 데이터가 전송되기 전, 클라이언트는 79번 바이트를 기다리고, 서버는 42번 바이트를 기다립니다.

- 전송되는 세그먼트
  ###### 첫번째 세그먼트
  - 클라이언트 'C' ASCII 표현(1바이트)을 포함하는 세그먼트 서버에 전송
  - 이 세그먼는 시퀸스 번호 42를 가지고 있으며, 서버로 부터 받은 데이터가 없기 때문에 응답 번호 필드에는 79만 있음
    
  ###### 두번째 세그먼트(서버 -> 클라이언트)
  - 서버 두 가지 목적을 가진 세그먼트를 클라이언트로 전송함
  - 첫 번째 목적은 클라이언트가 보낸 데이터를 확인으로 확인 응답 번호 필드에 43을 넣어 클라이언트에게 "나는 42번까지 잘 받았고 이제 43번 바이트를 기다리고 있어" 라고 알림
  - 두번 째 목적은 C를 에코 백 하는 것으로 이 세그먼트의 시퀸스 번호는 79이며, 서버가 클라이언트에게 보내는 첫 번째 데이터임 이것을 "피기백"이라고 함

  ###### 세번째 세그먼트(클라이언트 -> 서버)
  - 서버로 부터 받은 데이터를 확인하는 것
  - 이 세그먼트를 데이터 필드가 비어 있고, 확인 응답번호에는 80이 들어감 이는 클라이언트가 79번 잘 받았고 80번 바이트를 기다리고 있다는 걸 의미함
  - 데이터가 없는 세그먼트에도 시퀸스 번호가 존재하는 이유는 TCP가 시퀸스 번호 필드를 가지기 때문임.

### 3.5.3 왕복 시간 추정 및 타임아웃
- TCP는 rdt 프로토콜 처럼 손실된 세그먼트를 복구하기 위해 타임아웃/재전송 메커니즘을 사용함.
- 가장 중요한 건 타임 아웃의 간격의 길이로 타임아웃 -> 연결의 왕복 시간(RTT), 즉 세그먼트를 전송한 시점부터 그 세그먼트에 대한 확인 응답이 돌아오기 까지의 시간보다 길어야함.

#### 왕복 시간 추정하기
- 특정 세그먼트에 대한 RTT(SampleRTT)는 세그먼트가 전송된 시점(즉, IP에 전달된 시점)과 그 세그먼트에 대한 확인 응답이 수신된 시점 사이의 간격임.
- 전송된 모든 세그먼트에 대해 SampleRTT를 측정하는 대신, 한번에 하나의 SampleRTT 측정만 수행함.
- 특정 시점에서 SampleRTT는 현재 미승인 세그먼트 중 하나에 대해서만 추정되며, 새로은 SampleRTT 값은 대략 RTT마다 업데이트됨.
- 또한 TCP는 재전송된 세그먼트에 대해 SampleRTT를 계산하지 않고, 한 번만 전송된 세그먼트에 대해서만 측정함
- SampleRTT의 값이 각 변동되므로 SampleRTT값의 평균을 구하는 것이 자연스러움
- TCP는 ![image](https://github.com/user-attachments/assets/b6649947-cee9-464c-abb3-4edba5cc7375) 사용함
- 이는 SampleRTT의 가중평균으로 최근 샘플에 더 많은 가중치를 부여함.
- RTT의 변동성을 측정하는 것도 있는데 ![image](https://github.com/user-attachments/assets/be30e64d-080b-485a-9117-c860650eca45)
#### 재전송 타임아웃 간격 설정 및 관리
- EstimatedRTT와 DevRTT값을 고려했을 때 EstimatedRTT 보다 크거나 같아야 하며 그렇지 않으면 불필요한 재전송이 발생할 수 있음.
- 타임아웃 간격이 Estimated RTT보다 커지는것도 안되는데 그러면 세그먼트가 손실된 경우 TCP가 세그먼트를 신속하게 재전송하지 못해 데이터 전송지연이 발생가능
- 그래서 타임아웃을 Estimated RTT 보다 여유있는 값으로 설정함 SampleRTT 값이 변동성이 클 때는 크기, 변동성이 적을 때는 작게 설정. 이때 DevRTT가 영향을 미침
- ![image](https://github.com/user-attachments/assets/4adeded8-7e45-4f09-9d56-ef46c9263728)


