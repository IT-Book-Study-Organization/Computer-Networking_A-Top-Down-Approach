### 3.3 Connectionless Transport: UDP ###

---

**UDP의 처리 과정**

- **1단계** 
애플리케이션 프로세스에서 메시지를 수신하여 해당 메시지에 소스 및 목적지 포트 번호 필드를 포함한 세그먼트를 생성.  

- **2단계**
경량의 오류 검사를 수행하고 IP 계층으로 세그먼트를 전달하여 IP 데이터그램으로 캡슐화. 네트워크 계층이 최선으로해당 데이터그램을 목적지 호스트로 전송.  

- **3단계**
목적지 호스트의 UDP는 도착한 세그먼트를 수신하고 포트 번호를 통해 적절한 애플리케이션 프로세스에 전달.  

- **참고:** UDP는 연결 설정을 위한 핸드셰이킹이 없으며, 연결 상태를 유지하지 않는 비연결형 프로토콜.

---

**예시: DNS 쿼리 처리 과정**

- **1단계**  
호스트의 DNS 애플리케이션이 DNS 쿼리 메시지를 생성하여 UDP 계층으로 전달.

- **2단계**  
UDP는 핸드셰이킹 없이 쿼리 메시지에 헤더 필드를 추가하여 UDP 세그먼트를 생성하고 이를 네트워크 계층으로 전달.

- **3단계**  
네트워크 계층은 UDP 세그먼트를 IP 데이터그램으로 캡슐화하여 네임 서버로 전송.

- **4단계**  
쿼리한 호스트의 DNS 애플리케이션은 응답 메시지를 기다림.

- **5단계**  
응답을 받지 못한 경우, DNS 애플리케이션은 다음과 같은 대응을 할수 있음:
- 쿼리를 다시 전송
- 다른 네임 서버로 쿼리 시도
- 호출한 애플리케이션에 응답을 받을 수 없음을 알림

DNS는 비연결형 UDP 기반으로 동작하므로, 네트워크 손실로 인해 응답을 받지 못할 수 있음.

---

**왜 UDP를 사용하는지?**

**1) 애플리케이션 수준에서 데이터 전송 시점과 전송 내용에 대한 더 세밀한 제어**

**TCP**
- 혼잡 제어 메커니즘을 통해 송신지와 수신지 호스트 간의 하나 이상의 링크가 과도하게 혼잡해질 경우 전송 계층의 TCP 송신 속도를 제한.  또한, 세그먼트의 수신이 목적지로부터 확인될 때까지 해당 세그먼트를 계속 재전송하며, 신뢰할 수 있는 전송이 완료되는 데 걸리는 시간과는 무관하게 재전송을 지속.

**UDP** 
- 애플리케이션 프로세스가 데이터를 UDP에 전달하는 즉시, 해당 데이터를 UDP 세그먼트로 패키징하여 네트워크 계층에 바로 전달. 

- 실시간 애플리케이션은 일반적으로
	- 최소 전송 속도를 필요로함.
	- 세그먼트 전송을 지나치게 지연시키기를 원하지 않음. 
	- 일부 데이터 손실을 허용할 수 있음.

- 그러므로 TCP의 서비스 모델은 이러한 애플리케이션의 요구사항에 적합 X.  

**2) 연결 설정이 필요하지 않음**

**TCP**
데이터를 전송하기 전 세 번의 핸드셰이킹 과정을 거침.

**UDP**
이러한 공식적인 절차 없이 바로 데이터를 전송함으로써 연결을 설정하는데 지연을 발생시키지 않음.

HTTP는 텍스트를 포함한 웹 페이지의 신뢰성이 중요하기 때문에 UDP 대신 TCP를 사용하나, TCP 연결 설정 지연은 웹 문서를 다운로드할 때 발생하는 지연의 중요한 원인 중 하나.

실제 Google의 Chrome 브라우저에서 사용되는 QUIC(Quick UDP Internet Connection) 프로토콜은 UDP를 기반으로 하고 있으며, 애플리케이션 계층 프로토콜을 통해 신뢰성을 구현. (자세한 내용은 3.8)

**3) 연결 상태가 없음**

**TCP**
- 종단 시스템에서 연결 상태를 유지.
- 이 연결 상태에는 수신 및 송신 버퍼, 혼잡 제어 파라미터, 시퀀스 및 확인 응답 번호 파라미터가 포함됨. 이 상태 정보는 TCP의 신뢰할 수 있는 데이터 전송 서비스와 혼잡 제어를 구현하는데 필요. (자세한 내용은 3.5)

**UDP**
- 연결 상태를 유지하지 않으며, 이러한 파라미터를 추적 X

이러한 이유로 특정 애플리케이션에 전념하는 서버와 같은 경우 UDP를 사용할 때 일반적으로 더 많은 활성 클라이언트 지원 가능.

**4) 작은 패킷 헤더 오버헤드**

**TCP**
- 각 세그먼트마다 20바이트의 헤더 오버헤드를 가짐

**UDP**
- 8바이트의 헤더 오버헤드를 가짐. 

*헤더 오버헤드란?*
- 네트워크 패킷에 포함된 필수 제어 정보의 크기. 크기가 클수록 네트워크 리소스가 더 많이 소모되어, 작을수록 전송 효율이 높아짐.

---

**실제 사용되는 애플리케이션들에서 인기있는 전송 프로토콜**

![[Pasted image 20250110183750.png]]

인터넷 전화, 실시간 화상 회의, 저장된 오디오 및 비디오 스트리밍과 같은 멀티미디어 애플리케이션에서는 UDP/TCP 모두 사용되는 경우가 있음. 이러한 애플리케이션들은 소량의 패킷 손실이 허용되므로, 신뢰할 수 있는 데이터 전송이 필수적인 요소가 아님.

실시간 애플리케이션 (인터넷 전화, 실시간 화상 회의 등)은 TCP의 혼잡 제어에 매우 부정적인 반응을 보임. 그렇기에 위 애플리케이션 개발자들은 UDP를 사용하여 애플리케이션을 실행하기도 함.

그러나, 패킷 손실률이 낮고 일부 조직에서 보안상의 이유로 UDP 트래픽을 차단하는 경우(자세한 내용은 8장), TCP가 더 매력적인 선택지가 됨.

---

**주의사항**

- 네트워크가 매우 적은 양의 유용한 작업만 수행할 수 있는 혼잡 상태에 빠지지 않도록 하기 위해서는 혼잡 제어는 필수적이나, UDP는 혼잡 제어 기능을 제공하지 않음.
- 제어되지 않은 UDP 송신자가 초래하는 높은 손실률은 TCP 송신자가 혼잡을 감지했을 때 전송 속도를 줄이기 때문에 TCP 송신자의 전송 속도를 급격히 낮춤.
- 따라서 UDP에서 혼잡 제어가 부족하면 UDP 송신자와 수신 간 높은 손실률이 발생하며, TCP 세션이 밀려나 네트워크 성능이 저하될 수 있음. 
- 이를 해결하기 위해 UDP 송신자를 포함한 모든 송신자가 적응형 혼잡 제어를 수행하도록 강제하는 새로운 메커니즘이 제안되었음.

---

*추가 내용*

UDP를 사용할 때도 애플리케이션이 신뢰할 수 있는 데이터 전송 구현은 가능함. 
- How? 애플리케이션 자체에 확인 응답 및 재전송 메커니즘을 추가하여 신뢰성을 구축.
- 위에서 예시로 들었던 QUIC 프로토콜과 같은 경우 UDP 위에 애플리케이션 계층 프로토콜을 통해 신뢰성을 구현.
- 이를 위해서는 애플리케이션 개발자가 오랜 시간 디버깅 작업에 몰두해야 할 만큼 단순한 작업은 아니나, 이걸 구축하게 된다면 TCP의 혼잡 제어 메커니즘이 부과하는 전송 속도 제한을 받지 않고도 신뢰성 있는 통신이 가능해진다는 장점이 있음.

---

***3.3.1 UDP Segment Structure***

![[Pasted image 20250110190046.png]]

- 애플리케이션 데이터는 UDP 세그먼트의 데이터 필드에 위치.

- UDP 헤더는 총 4개의 필드로 구성되며, 각 필드는 2바이트 크기.
	- 포트 번호: 목적지 호스트가 수신된 애플리케이션 데이터를 목적지 종단 시스템에서 실행 중인 올바른 프로세스에 전달할 수 있도록 함. (디멀티플렉싱 기능 수행)
	- 길이 필드: UDP 세그먼트의 바이트 수 지정
	- 체크섬 필드: 수신 호스트가 세그먼트에 오류가 발생했는지 확인하는데 사용.
	- 길이 필드: 헤더를 포함한 UDP 세그먼트의 전체 길이를 바이트 단위로 지정.

*실제 체크섬은 UDP 세그먼트 뿐만이 아닌 IP 헤더의 일부 필드를 포함하여 계산하나, 복잡함을 피하기 위해 여기서는 설명하지 않음.*

---

***3.3.2 UDP Checksum***
