## **Pipelined Reliable Data Transfer Protocols**   
###### Stop-and-Wait 프로토콜의 성능 문제와 파이프라이닝 개념  

### **1. Stop-and-Wait 프로토콜의 문제점**  
**rdt3.0 프로토콜**은 신뢰성을 보장하기 위해 **Stop-and-Wait** 방식을 사용하지만, 이 방식은 네트워크 환경에서 매우 비효율적  

- **작동 방식:** 송신기는 하나의 패킷을 전송한 후, 해당 패킷의 ACK(확인 응답)를 수신할 때까지 대기함  
- **상황:**  
    - **송신기와 수신기 간 거리:** 미국 동부 ↔ 서부 (RTT ≈ 30ms)  
    - **전송 속도(R):** 1 Gbps  
    - **패킷 크기(L):** 1,000 bytes (8,000 bits)  

    **계산:**  
    1. **패킷 전송 시간 (dtrans):**  
    - 패킷을 링크에 전송하는 데 걸리는 시간  
    \[
    d_{\text{trans}} = \frac{L}{R} = \frac{8,000 \text{ bits}}{10^9 \text{ bits/sec}} = 8 \mu s
    \]  
    → **패킷 전송 시간:** 8μs  

    2. **송신기 이용률 (Usender):**  
    - 송신기가 데이터를 전송하는 시간의 비율  
    \[
    U_{\text{sender}} = \frac{d_{\text{trans}}}{RTT + d_{\text{trans}}} = \frac{0.008 \text{ ms}}{30.008 \text{ ms}} \approx 0.00027 \, (0.027\%)
    \]  
   → **송신기 이용률:** 0.027%
    **해석:** 실제 1 Gbps의 링크를 사용하지만, 실질적인 전송률은 267 kbps에 불과함.  

**결과:** 송신기가 패킷을 전송한 후 ACK를 기다리는 동안 대기 시간이 길어져, 고속 네트워크 환경에서도 대역폭을 효과적으로 사용하지 못함.

### **2. 파이프라이닝(Pipelining) 개념**  
Stop-and-Wait 방식의 문제를 해결하기 위해 `파이프라이닝` 기법이 도입되었습니다.  

- **개념:** 송신기가 ACK를 기다리지 않고 **여러 개의 패킷을 연속 전송**하여 전송 파이프라인을 채움.  
- **효과:** 동시에 여러 패킷이 송신됨으로써 송신기 이용률이 크게 증가함.  
- **요구사항:**   
1. **순서 번호 범위 증가:**  
   - 여러 패킷을 동시에 전송하므로, 각 패킷에는 고유한 순서 번호가 필요함.  
2. **버퍼링:**  
   - 송신기: ACK를 받지 않은 패킷을 저장해야 함.  
   - 수신기: 도착한 패킷을 순서대로 맞추기 위해 버퍼링이 필요할 수 있음.  
3. **오류 복구 전략:**  
   - 데이터 손실, 손상, 지연 상황에서 이를 복구하기 위한 프로토콜이 필요함.  

---

## **Go-Back-N (GBN) 프로토콜**   
###### [GBN Animation](https://www.tkn.tu-berlin.de/teaching/rn/animations/gbn_sr/)   

### **1. GBN 프로토콜 개요**  
GBN 프로토콜은 **슬라이딩 윈도우 방식**을 사용하여, 송신기가 **최대 N개의 패킷**을 연속 전송할 수 있도록 합니다. 다만, ACK(확인 응답)를 받지 못한 패킷이 **N개를 초과**하면 송신을 중단합니다.

### **2. 주요 개념**  
- **윈도우 크기(N):** 송신기가 동시에 보낼 수 있는 패킷 수.  
- **누적 ACK:** 수신기는 패킷 `n`에 대한 ACK를 보내며 `n` 이하의 모든 패킷이 수신되었음을 알림.  
- **시퀀스 번호:** 패킷에 붙는 고유 번호. 시퀀스 번호는 순환되며 `[0, 2^k - 1]` 범위를 가짐.

### **3. 동작 방식**  
1. **송신기**  
   - **패킷 전송:** 윈도우가 가득 차지 않았다면 패킷을 전송.  
   - **ACK 수신:** 가장 오래된 패킷부터 순서대로 ACK를 확인 후 윈도우를 이동.  
   - **타임아웃:** 특정 패킷의 ACK가 도착하지 않으면 **모든 미확인 패킷**을 재전송.  

2. **수신기**  
   - **순서대로 수신:** 패킷이 올바른 순서로 도착하면 상위 계층에 전달하고 ACK 전송.  
   - **순서가 틀리거나 손상:** 패킷을 버리고, 마지막으로 정상 수신된 패킷의 ACK를 재전송.

### **4. 장점과 단점**  
- **장점:** 구현이 간단하며, 수신기 측 버퍼링이 불필요함.  
- **단점:** 패킷 손실 시 모든 미확인 패킷을 재전송하므로 네트워크 효율이 낮아질 수 있음.

### **5. GBN 프로토콜 예시**  
- **윈도우 크기:** 4  
- **패킷 전송:** `0`, `1`, `2`, `3` 전송 후 대기.  
- **패킷 2 손실 시:** 수신기가 `3`, `4`, `5`를 버림 → 송신기가 `2`부터 다시 전송.

