# **Pipelined Reliable Data Transfer Protocols**   
###### Stop-and-Wait 프로토콜의 성능 문제와 파이프라이닝 개념  

## 3.4.2 Pipelined Reliable Data Transfer Protocols

### **1. Stop-and-Wait 프로토콜의 문제점**  
**rdt3.0 프로토콜**은 신뢰성을 보장하기 위해 **Stop-and-Wait** 방식을 사용하지만, 이 방식은 네트워크 환경에서 매우 비효율적  

- **작동 방식:** 송신기는 하나의 패킷을 전송한 후, 해당 패킷의 ACK(확인 응답)를 수신할 때까지 대기함  
- **성능 분석 예시:**  
  - **송신기와 수신기 간 거리:** 미국 동부 ↔ 서부 (RTT ≈ 30ms)  
  - **전송 속도(R):** 1 Gbps  
  - **패킷 크기(L):** 1,000 bytes (8,000 bits)  
  - **패킷 전송 시간(dtrans):**  
    $\( d_{\text{trans}} = \frac{L}{R} = \frac{8,000 \text{ bits}}{10^9 \text{ bits/sec}} = 8 \text{ microseconds} \)$   
  - **송신기 이용률(Usender):**  
    $\( U_{\text{sender}} = \frac{L / R}{RTT + L / R} = \frac{0.008 \text{ ms}}{30.008 \text{ ms}} = 0.00027 \)$   
    **해석:** 실제 1 Gbps의 링크를 사용하지만, 실질적인 전송률은 267 kbps에 불과함  

**결과:** 송신기가 패킷을 전송한 후 ACK를 기다리는 동안 대기 시간이 길어져, 고속 네트워크 환경에서도 대역폭을 효과적으로 사용하지 못함

### **2. 파이프라이닝(Pipelining) 개념**  
Stop-and-Wait 방식의 문제를 해결하기 위해 `파이프라이닝` 기법 도입  

- **개념:** 송신기가 ACK를 기다리지 않고 **여러 개의 패킷을 연속 전송**하여 전송 파이프라인을 채움  
- **효과:** 동시에 여러 패킷이 송신됨으로써 송신기 이용률이 크게 증가함  
- **요구사항:**   
1. **순서 번호 범위 증가:**  
   - 여러 패킷을 동시에 전송하므로, 각 패킷에는 고유한 순서 번호가 필요함  
2. **버퍼링:**  
   - 송신기: ACK를 받지 않은 패킷을 저장해야 함  
   - 수신기: 도착한 패킷을 순서대로 맞추기 위해 버퍼링이 필요할 수 있음  
3. **오류 복구 전략:**  
   - 데이터 손실, 손상, 지연 상황에서 이를 복구하기 위한 프로토콜이 필요함  

---

## 3.4.3 Go-Back-N (GBN)

### **1. 개념**  
GBN 프로토콜은 **슬라이딩 윈도우 방식**을 사용하여, 송신기가 **최대 N개의 패킷**을 연속 전송할 수 있도록 합니다. 다만, ACK(확인 응답)를 받지 못한 패킷이 **N개를 초과**하면 송신을 중단합니다.
- **윈도우 크기(N):** 송신기가 동시에 보낼 수 있는 패킷 수  
- **누적 ACK:** 수신기는 패킷 `n`에 대한 ACK를 보내며 `n` 이하의 모든 패킷이 수신되었음을 알림  
- **시퀀스 번호:** 패킷에 붙는 고유 번호. 시퀀스 번호는 순환되며 `[0, 2^k - 1]` 범위를 가짐

### **2. 동작 방식**  
1. **송신기**  
   - **패킷 전송:** 윈도우가 가득 차지 않았다면 패킷을 전송  
   - **ACK 수신:** 가장 오래된 패킷부터 순서대로 ACK를 확인 후 윈도우를 이동  
   - **타임아웃:** 특정 패킷의 ACK가 도착하지 않으면 **모든 미확인 패킷**을 재전송  

2. **수신기**  
   - **순서대로 수신:** 패킷이 올바른 순서로 도착하면 상위 계층에 전달하고 ACK 전송  
   - **순서가 틀리거나 손상:** 패킷을 버리고, 마지막으로 정상 수신된 패킷의 ACK를 재전송

### **3. 장점과 단점**  
- **장점:** 구현이 간단하며, 수신기 측 버퍼링이 불필요함  
- **단점:** 패킷 손실 시 모든 미확인 패킷을 재전송하므로 네트워크 효율이 낮아질 수 있음

### **4. GBN 프로토콜 예시**  
- **윈도우 크기:** 4  
- **패킷 전송:** `0`, `1`, `2`, `3` 전송 후 대기  
- **패킷 2 손실 시:** 수신기가 `3`, `4`, `5`를 버림 → 송신기가 `2`부터 다시 전송

### **5. 문제점**
GBN(Go-Back-N) 프로토콜은 여러 패킷을 연속적으로 전송할 수 있지만, **한 패킷이라도 손실되면 해당 패킷 이후의 모든 패킷을 재전송**해야 함  
- **대역폭 낭비:** 단일 패킷 손실로 인해 이미 수신된 패킷을 불필요하게 재전송함  
- **채널 에러 증가 시 비효율성:** 오류 확률이 높을수록 재전송되는 패킷의 양이 많아짐  
  - 예를 들어, 윈도우 크기가 1,000일 경우, 패킷 하나가 손실되면 1,000개 패킷을 재전송해야 함  

**해결해야 할 문제:**  
- 불필요한 재전송을 줄이고 전송 효율을 향상시킬 수 있는 방법 필요

---

## 3.4.4 Selective Repeat (SR) 

### **1. 개념**
Selective Repeat(SR) 프로토콜은 **필요한 패킷만 선택적으로 재전송**하여 불필요한 재전송을 피함  
- **개념:** 손실되거나 손상된 패킷만 개별적으로 재전송함  
- **윈도우 크기 (N):** 송신기가 동시에 전송할 수 있는 패킷의 최대 개수는 N으로 제한됨  

**GBN과의 차이점:**  
- GBN은 누적 ACK 방식 사용 → 손실된 패킷 이후 모든 패킷 재전송  
- SR은 개별 ACK 방식 사용 → 손실된 패킷만 선택적으로 재전송

### **2. 동작 방식**   
#### **SR Sender**  
1. **데이터 전송 요청:**  
   - 상위 계층에서 데이터가 도착하면, 시퀀스 번호가 송신 윈도우 범위 내에 있으면 패킷을 전송.  
   - 시퀀스 번호가 윈도우 범위를 벗어나면 데이터를 버퍼에 저장하거나 상위 계층으로 반환함.  

2. **타임아웃:**  
   - 각 패킷마다 개별적으로 타이머를 설정함.  
   - 특정 패킷이 손실되거나 지연될 경우 해당 패킷만 재전송.  

3. **ACK 수신:**  
   - ACK를 수신하면 해당 패킷을 성공적으로 수신된 것으로 표시함.  
   - `send_base` 값(윈도우의 시작)을 업데이트하여 윈도우를 이동함.  
   - 윈도우 범위 내 전송되지 않은 패킷이 있으면 해당 패킷을 전송.

#### **SR Receiver**  
1. **정상 수신:**  
   - 패킷이 올바르게 수신되면 ACK를 송신기에게 전송.  
   - 패킷이 순서에 맞지 않더라도 일단 버퍼에 저장함.  
   - `rcv_base`(수신 윈도우의 시작)과 일치하는 패킷이 수신되면 버퍼에 저장된 패킷을 순서대로 상위 계층으로 전달함.

2. **중복 패킷 수신:**  
   - 이미 ACK를 보낸 패킷을 다시 수신하면, 중복 ACK를 다시 보냄.

3. **잘못된 패킷 수신:**  
   - 패킷 번호가 수신 윈도우를 벗어나는 경우 패킷을 무시함.

### **3. 장점과 단점**  
- **장점:**  
  - 손실된 패킷만 재전송하므로 대역폭을 효율적으로 사용 가능.  
  - 수신기는 버퍼링을 통해 순서가 맞지 않은 패킷도 처리 가능.  

- **단점:**  
  - 각 패킷마다 개별적인 타이머와 버퍼링이 필요하므로 구현이 복잡함.  
  - 시퀀스 번호 재사용 시 데이터 중복 문제 발생 가능.

#### [참조(GBN/SR Animation)](https://www.tkn.tu-berlin.de/teaching/rn/animations/gbn_sr/)
#### [영상(GBN/SR Animation)](https://www.youtube.com/watch?v=Cs8tR8A9jm8)
