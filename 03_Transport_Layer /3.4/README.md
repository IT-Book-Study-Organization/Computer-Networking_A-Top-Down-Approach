## 3.4 Principles of Reliable Data Transfer

### 개요
- 신뢰성 있는 데이터 전송 문제는 네트워킹에서 중요한 문제로, 전송 계층, 링크 계층, 애플리케이션 계층에서도 발생함.
- TCP는 데이터 손상, 손실, 순서 보장 문제를 해결하는 원칙을 통해 신뢰성 있는 데이터 전송 서비스를 제공함.
- 신뢰성 있는 데이터 전송 프로토콜은 다음을 보장함:
  - 데이터 손상 및 손실 방지
  - 데이터 순서 보장
- 본 챕터에서는 다양한 유형의 비신뢰 채널에 대한 신뢰성 있는 데이터 전송 프로토콜을 개발함.

![image](https://github.com/user-attachments/assets/57f91ded-9327-4dca-95bf-98d67d0d4638)

### **3.8 - a: 제공되는 서비스**
- 전송 계층에서 신뢰성 있는 채널의 추상적 서비스 모델을 나타냄.
- 데이터가 손상, 손실, 순서 뒤바뀜 없이 전송되어 상위 계층 프로세스에 원활한 서비스를 제공함.

### **3.8 - b : 서비스 구현**
- 비신뢰 채널 위에 신뢰성 있는 데이터 전송 프로토콜을 실제로 구현한 구조를 나타냄.
- 주요 구성 요소:
     - `rdt_send()`: 송신 프로세스에서 데이터를 전송할 때 호출됨.
     - `udt_send()`: 비신뢰 채널을 통해 데이터를 전송할 때 호출됨.
     - `rdt_rcv()`: 수신 측에서 패킷이 도착했을 때 호출됨.
     - `deliver_data()`: 수신 측에서 데이터를 상위 계층에 전달할 때 호출됨.

### 설계 구현
- 인터넷 전송 계층에 국한되지 않기 위해 "세그먼트" 대신 "패킷"이라는 용어를 사용함.
- 이 챕터에서는 단방향 데이터 전송의 경우만 고려.
- 데이터 패킷 외에도 신뢰성을 보장하기 위해 제어 패킷을 교환해야 함.
- 송신 측과 수신 측 모두 `udt_send()` 호출을 통해 상대방에게 패킷을 전송해야 함.
- 신뢰성이 없는 하위 계층 위에서도 신뢰성 있는 데이터 전송을 구현하는 것이 목표임.
  
## 3.4.1 Building a Reliable Data Transfer Protocol

### Reliable Data Transfer over a Perfectly Reliable Channel: rdt1.0

- **rdt(신뢰적 데이터 전송)** : 하위 계층에서 상위 계층에서 데이터를 전송할 때 전송된 데이터가 손상되거나 손실되지 않게 보장하는 개념
- rdt1.0은 **완벽히 신뢰성 있는 채널**을 가정하여 설계된 가장 단순한 프로토콜임.
- 이 프로토콜에서는 데이터 손상, 손실, 순서 뒤바뀜이 전혀 발생하지 않음.
- rdt1.0의 송신기와 수신기는 각각 하나의 상태만 가지며, FSM(Finite-State Machine, 유한 상태 기계, 상태(state)를 기반으로 동작을 제어하는 방식을 구현하기 위한 디자인 패턴)은 간단한 전이 구조로 이루어짐.

![image](https://github.com/user-attachments/assets/e78728bd-11ca-493c-a6c6-e11bc9a43a53)

### **3.9 - a : rdt1.0 송신기 동작**
- **상태**: 상위 계층에서 호출을 대기함.
- **동작**:
 1. `make_pkt(data)`로 데이터를 포함한 패킷 생성.
 2. `udt_send(packet)`을 호출하여 비신뢰 채널에 패킷 전송.
- **설명**: 송신기는 상위 계층의 데이터 전송 요청을 받아 패킷을 생성하고 채널에 전송함.

### **3.9 - b : rdt1.0 수신기 동작**
- **상태**: 하위 계층에서 호출을 대기함.
- **동작**:
 1. `extract(packet, data)`로 패킷에서 데이터를 추출.
 2. `deliver_data(data)`를 호출하여 상위 계층에 데이터 전달.
- **설명**: 수신기는 하위 계층으로부터 패킷을 수신하여 데이터를 추출한 후, 이를 상위 계층에 전달함.

### 설계 구현
- 패킷은 송신기에서 수신기로만 전송되며, 수신기가 송신기에게 피드백을 보낼 필요가 없음.
- 완벽한 신뢰성 있는 채널을 가정하므로 패킷 손실이나 오류가 발생하지 않음.
- 수신 속도가 송신 속도와 동일하다고 가정하므로, 송신 속도 제어가 필요하지 않음.

---

### Reliable Data Transfer over a Channel with Bit Errors: rdt2.0

- 실제 네트워크 환경에서는 패킷 전송 과정에서 **비트 손상(bit error)**이 발생할 수 있음.
- rdt2.0은 이러한 비트 손상 문제를 해결하기 위해 설계된 프로토콜로, 패킷의 **비트 오류 감지**와 **재전송** 기능을 제공함.
- 패킷은 송신된 순서대로 수신되지만, 비트 오류가 발생할 가능성을 고려하여 설계됨.

1. **오류 감지 (Error Detection)**
   - 수신 측에서 비트 오류를 감지할 수 있는 메커니즘이 필요함.
   - UDP의 인터넷 체크섬 필드와 유사한 방식으로 오류를 감지하며, 이를 위해 송신자는 데이터 외에 추가적인 비트를 전송함.
   - rdt2.0 패킷에 **체크섬 필드**를 포함하여 오류 검출에 사용함.

2. **수신자 피드백 (Receiver Feedback)**
   - 송신자와 수신자는 물리적으로 멀리 떨어져 있을 수 있으므로, 송신자가 수신자의 상태(패킷이 정상 수신되었는지 여부)를 알기 위해 수신자의 명시적인 피드백이 필요함.
   - 수신자는 다음 두 종류의 피드백 패킷을 송신자에게 전송함:
     - **긍정 응답(ACK)**: 패킷이 정상적으로 수신되었음을 알림.
     - **부정 응답(NAK)**: 패킷이 손상되었음을 알리고 재전송을 요청함.
   - 이 피드백 패킷은 1비트로 표현할 수 있으며, `0`은 NAK, `1`은 ACK를 나타냄.

3. **재전송 (Retransmission)**
   - 수신자가 오류가 발생한 패킷에 대해 NAK를 보낼 경우, 송신자는 해당 패킷을 다시 전송함.
   - 이 과정은 수신자가 오류 없는 패킷을 정상적으로 수신할 때까지 반복됨.

- rdt2.0은 **비트 오류 감지**, **긍정 응답(ACK)** 및 **부정 응답(NAK)**을 사용하는 **Stop-and-Wait** 프로토콜임.
- 송신기와 수신기는 각각 고유한 상태 전이(FSM)를 통해 동작하며, 오류가 발생한 패킷에 대해 재전송을 수행함.
- 이 프로토콜은 ACK/NAK 패킷이 손상될 수 있다는 문제를 해결하기 위한 추가 메커니즘이 필요함.

### ARQ 프로토콜
- rdt2.0은 **ARQ(Automatic Repeat reQuest) 프로토콜**을 기반으로 동작하며, 다음 세 가지 주요 기능을 가짐:
  - **오류 감지**
  - **피드백 제공**
  - **오류 발생 시 재전송**

---

![image](https://github.com/user-attachments/assets/63a533c3-eddc-4598-a349-76faebfc60d5)

**ACK (Acknowledgment)**:  
   - 송신된 패킷이 **정상적으로 수신되었음을 알리는 긍정 응답**.  
   - 송신자가 ACK를 수신하면 해당 패킷이 손상 없이 도착했음을 확인하고 새로운 데이터를 전송할 수 있음.  
   - ACK 패킷은 일반적으로 `1`로 표시됨.

**NAK (Negative Acknowledgment)**:  
   - 송신된 패킷에 **오류가 발생했음을 알리는 부정 응답**.  
   - 송신자는 NAK를 수신하면 해당 패킷을 재전송함.  
   - NAK 패킷은 일반적으로 `0`으로 표시됨.

---

### **3.10 - a : rdt2.0 송신기 동작**

1. **상태 1: Wait for call from above**
   - 송신기는 상위 계층에서 `rdt_send(data)` 호출이 발생할 때까지 대기.
   - 호출이 발생하면 `make_pkt(data, checksum)`을 통해 데이터를 포함한 패킷을 생성하고 `udt_send(sndpkt)`로 전송.
   - 이후 ACK 또는 NAK 응답을 기다리는 상태로 전이함.

2. **상태 2: Wait for ACK or NAK**
   - 수신자로부터 ACK 또는 NAK 응답을 대기.
   - `rdt_rcv(rcvpkt) && isACK(rcvpkt)` 조건이 충족되면 ACK 수신으로 간주하고, 상태 1로 돌아가 새로운 데이터를 수신할 준비를 함.
   - `rdt_rcv(rcvpkt) && isNAK(rcvpkt)` 조건이 충족되면 NAK 수신으로 간주하고 이전에 전송한 패킷을 재전송한 후 상태 2를 유지함.

3. **Stop-and-Wait 특성**
   - 송신기는 ACK를 받을 때까지 새로운 데이터를 전송하지 않음.
   - 이 동작 방식 때문에 rdt2.0은 **Stop-and-Wait 프로토콜**로 분류됨.

### **3.10 - b : rdt2.0 수신기 동작**

1. **패킷 수신 대기**
   - 수신기는 `rdt_rcv(rcvpkt)` 호출이 발생할 때까지 대기.
   
2. **패킷 검증 및 응답**
   - `rdt_rcv(rcvpkt) && corrupt(rcvpkt)` 조건이 충족되면 패킷이 손상된 것으로 간주하고 NAK를 생성하여 `udt_send(sndpkt)`로 전송.
   - `rdt_rcv(rcvpkt) && notcorrupt(rcvpkt)` 조건이 충족되면 패킷이 정상임을 확인하고 데이터를 추출한 후 상위 계층으로 전달(`deliver_data(data)`)하고 ACK를 전송.

3. **NAK와 ACK 동작**
   - 손상된 패킷에 대해 NAK 응답을 보내 송신자가 재전송하도록 함.
   - 정상 패킷에 대해 ACK 응답을 보내 다음 데이터 전송을 요청함.

### ACK/NAK 문제
- ACK 또는 NAK 패킷이 손상될 수 있으며, 송신자는 수신자가 데이터를 제대로 수신했는지 알 수 없음.
- ACK/NAK 패킷 손상으로 인해 송신자는 중복 패킷을 전송하거나 데이터 무결성이 깨질 위험이 있음.

### 해결책
- **체크섬 추가**  
   - ACK 및 NAK 패킷에 체크섬 필드를 추가하여 오류를 감지함.

- **시퀀스 번호 추가**  
   - 데이터 패킷에 **1비트 시퀀스 번호**를 추가하여 수신자가 중복 패킷 여부를 판단할 수 있도록 함.  
   - 수신자는 시퀀스 번호를 통해 새 패킷인지 이전에 수신한 패킷인지 구별하여 중복 수신 문제를 해결함.  
   - 시퀀스 번호는 **modulo-2 연산**을 사용하여 `0`과 `1`을 반복함.(**모듈로-2 연산(modulo-2 arithmetic)** : 값을 2로 나눈 나머지를 구하는 연산 방식. 결과값은 항상 0 또는 1이 됨)

---

### rdt2.1 and rdt2.2
- **rdt2.1**은 **rdt2.0**에서 발생한 ACK/NAK 손상 문제를 해결하기 위해 시퀀스 번호(0 또는 1)를 도입하여 개선한 프로토콜임.
- 송신기와 수신기의 상태 수가 기존보다 2배로 증가하였으며, 각 상태에서 송신 및 수신되는 패킷에 대한 시퀀스 번호를 관리함.
- **rdt2.2**는 NAK 없는 프로토콜(NAK-free protocol)로, 수신기가 NAK 대신 **중복 ACK**를 전송하여 손상된 패킷을 처리함.

### 3.11 : rdt2.1 송신기 동작

![image](https://github.com/user-attachments/assets/e8cfd933-d1f7-42e7-854a-1422452e8470)

**상태 1: Wait for call 0 from above**
   - 상위 계층에서 `rdt_send(data)` 호출이 발생하면 시퀀스 번호 `0`을 포함한 패킷을 생성하고 전송.
   - 이후 ACK 또는 NAK 응답을 기다리는 상태로 전이.

**상태 2: Wait for ACK or NAK 0**
   - 수신기로부터 ACK 또는 NAK 응답을 대기.
   - `rdt_rcv(rcvpkt) && isACK(rcvpkt)` 조건을 만족하면 ACK 수신으로 간주하고 상태 3으로 전이.
   - `rdt_rcv(rcvpkt) && (corrupt(rcvpkt) || isNAK(rcvpkt))` 조건을 만족하면 NAK 수신으로 간주하고 패킷을 재전송한 후 상태 유지.

**상태 3: Wait for call 1 from above**
   - 상위 계층에서 새로운 데이터가 오면 시퀀스 번호 `1`을 포함한 패킷을 생성하고 전송.
   - 이후 ACK 또는 NAK 응답을 기다리는 상태로 전이.

**상태 4: Wait for ACK or NAK 1**
   - 상태 2와 유사하게 동작하되, 시퀀스 번호 `1`에 대한 ACK 또는 NAK 응답을 처리.

---

### 3.12 : rdt2.1 수신기 동작

![image](https://github.com/user-attachments/assets/a987d906-8cb3-4ea7-85c7-0a208b40d1eb)

**상태 1: Wait for 0 from below**
   - `rdt_rcv(rcvpkt) && corrupt(rcvpkt)` 조건을 만족하면 패킷이 손상된 것으로 간주하고 NAK를 전송.
   - `rdt_rcv(rcvpkt) && notcorrupt(rcvpkt) && has_seq0(rcvpkt)` 조건을 만족하면 패킷을 정상 수신한 것으로 간주하고 데이터를 상위 계층으로 전달한 후 ACK를 전송하며 상태 2로 전이.

**상태 2: Wait for 1 from below**
   - 상태 1과 유사하게 동작하되, 시퀀스 번호 `1`에 대한 패킷을 처리.

---

### 3.13 : rdt2.2 송신기 동작

![image](https://github.com/user-attachments/assets/f3eb1a69-c40d-4af7-bfbe-4b383f15aa08)

**상태1 : Wait for call 0 from above**  
   - 송신기는 상위 계층에서 `rdt_send(data)` 호출이 발생할 때까지 대기.  
   - 호출이 발생하면 시퀀스 번호 '0'과 체크섬을 포함한 패킷을 생성한 후 전송(`udt_send(sndpkt)`).  
   - 이후 **Wait for ACK 0** 상태로 전이하여 ACK 응답을 기다림.

**상태2 : Wait for ACK 0**  
   - 송신기는 ACK 패킷 수신을 대기하며, 다음 두 경우에 따라 동작:  
   - `rdt_rcv(rcvpkt) && notcorrupt(rcvpkt) && isACK(rcvpkt, 0)` 조건을 만족하면 ACK 0이 수신된 것으로 간주하고 **Wait for call 1 from above** 상태로 전이.  
   - `rdt_rcv(rcvpkt) && (corrupt(rcvpkt) || isACK(rcvpkt, 1))` 조건을 만족하면 NAK 또는 잘못된 ACK로 간주하고 이전 패킷을 재전송한 후 상태 유지.

**상태3 : Wait for call 1 from above**  
   - 상위 계층에서 새로운 데이터가 전달되면 시퀀스 번호 '1'과 체크섬을 포함한 패킷을 생성하여 전송.  
   - 이후 **Wait for ACK 1** 상태로 전이.

**상태4 : Wait for ACK 1**  
   - 송신기는 ACK 패킷 수신을 대기하며, 다음 두 경우에 따라 동작:  
   - `rdt_rcv(rcvpkt) && notcorrupt(rcvpkt) && isACK(rcvpkt, 1)` 조건이 충족되면 ACK 1이 수신된 것으로 간주하고 **Wait for call 0 from above** 상태로 전이.  
   - `rdt_rcv(rcvpkt) && (corrupt(rcvpkt) || isACK(rcvpkt, 0))` 조건을 만족하면 NAK 또는 잘못된 ACK로 간주하고 이전 패킷을 재전송한 후 상태 유지.

---

### 3.14 : rdt2.2 수신기 동작

![image](https://github.com/user-attachments/assets/61441d1c-9ffb-4625-b1cb-e1931fb35c72)

**상태 1 : Wait for 0 from below**  
   - 하위 계층에서 시퀀스 번호 '0'에 해당하는 패킷 수신을 대기.  
   - 수신한 패킷에 따라 다음과 같이 동작:  
     - `rdt_rcv(rcvpkt) && notcorrupt(rcvpkt) && has_seq0(rcvpkt)` 조건이 충족되면 정상 패킷으로 간주하고 데이터를 상위 계층으로 전달한 후 ACK 0을 전송.  
     - `rdt_rcv(rcvpkt) && (corrupt(rcvpkt) || has_seq1(rcvpkt))` 조건이 충족되면 손상된 패킷 또는 잘못된 시퀀스 번호의 패킷으로 간주하고 ACK 1을 재전송한 후 상태 유지.

2. **상태 2 : Wait for 1 from below**  
   - 하위 계층에서 시퀀스 번호 '1'에 해당하는 패킷 수신을 대기.  
   - 수신한 패킷에 따라 다음과 같이 동작:  
     - `rdt_rcv(rcvpkt) && notcorrupt(rcvpkt) && has_seq1(rcvpkt)` 조건이 충족되면 정상 패킷으로 간주하고 데이터를 상위 계층으로 전달한 후 ACK 1을 전송.  
     - `rdt_rcv(rcvpkt) && (corrupt(rcvpkt) || has_seq0(rcvpkt))` 조건이 충족되면 손상된 패킷 또는 잘못된 시퀀스 번호의 패킷으로 간주하고 ACK 0을 재전송한 후 상태 유지.

---

### Reliable Data Transfer over a Lossy Channel with Bit Errors: rdt3.0

- rdt3.0 : **비트 오류**와 **패킷 손실**을 모두 처리할 수 있는 신뢰성 있는 데이터 전송 프로토콜
- 이전 버전인 rdt2.2는 비트 오류를 처리할 수 있었으나 패킷 손실에 대해서는 대처할 수 없었음.
- **타이머 기반 재전송 메커니즘**을 도입하여 일정 시간 내에 ACK를 받지 못할 경우 패킷을 재전송함으로써 패킷 손실 문제를 해결.

### 핵심 기능
1. **타이머 기반 재전송**: 송신기는 패킷을 전송한 후 타이머를 시작하고, 일정 시간 내에 ACK를 받지 못하면 패킷을 재전송함.
2. **Stop-and-Wait 프로토콜**: 송신기는 ACK를 받을 때까지 새로운 데이터를 전송하지 않고 대기함.

---

### 3.15 : rdt 3.0 송신기 동작

![image](https://github.com/user-attachments/assets/c7f29156-04d2-47a3-8c9e-9d4335c60860)

**상태 1 : Wait for call 0 from above**
   - 상위 계층에서 데이터를 수신하면 시퀀스 번호 **0**과 체크섬을 포함한 패킷을 생성하고 전송(`udt_send(sndpkt)`), 이후 타이머를 시작(`start_timer`)함.
   - 이후 **Wait for ACK 0** 상태로 전이하여 ACK 수신을 대기함.

**상태 2 : Wait for ACK 0**
   - 송신기는 ACK 패킷 수신을 대기하며, 다음 조건에 따라 동작:
     - `rdt_rcv(rcvpkt) && notcorrupt(rcvpkt) && isACK(rcvpkt, 0)` 조건이 충족되면 ACK 0 수신으로 간주하고 타이머를 중지(`stop_timer`)한 후 **Wait for call 1 from above** 상태로 전이.
     - `timeout` 발생 시 이전에 전송한 패킷을 재전송(`udt_send(sndpkt)`)하고 타이머를 다시 시작(`start_timer`).

**상태 3 : Wait for call 1 from above**
   - 상위 계층에서 새로운 데이터를 수신하면 시퀀스 번호 **1**과 체크섬을 포함한 패킷을 생성하여 전송하고 타이머를 시작.
   - 이후 **Wait for ACK 1** 상태로 전이.

**상태 4 : for ACK 1**
   - 송신기는 ACK 1 수신을 대기하며, 다음 조건에 따라 동작:
     - `rdt_rcv(rcvpkt) && notcorrupt(rcvpkt) && isACK(rcvpkt, 1)` 조건이 충족되면 ACK 1 수신으로 간주하고 타이머를 중지한 후 **Wait for call 0 from above** 상태로 전이.
     - `timeout` 발생 시 이전 패킷을 재전송하고 타이머를 다시 시작.

---

## 3.4.2 Pipelined Reliable Data Transfer Protocols

### **1. Stop-and-Wait 프로토콜의 문제점**  
**rdt3.0 프로토콜**은 신뢰성을 보장하기 위해 **Stop-and-Wait** 방식을 사용하지만, 이 방식은 네트워크 환경에서 매우 비효율적  

- **작동 방식:** 송신기는 하나의 패킷을 전송한 후, 해당 패킷의 ACK(확인 응답)를 수신할 때까지 대기함  
- **성능 분석 예시:**  
  - **송신기와 수신기 간 거리:** 미국 동부 ↔ 서부 (RTT ≈ 30ms)  
  - **전송 속도(R):** 1 Gbps  
  - **패킷 크기(L):** 1,000 bytes (8,000 bits)  
  - **패킷 전송 시간(dtrans):**  
    $\( d_{\text{trans}} = \frac{L}{R} = \frac{8,000 \text{ bits}}{10^9 \text{ bits/sec}} = 8 \text{ microseconds} \)$   
  - **송신기 이용률(Usender):**  
    $\( U_{\text{sender}} = \frac{L / R}{RTT + L / R} = \frac{0.008 \text{ ms}}{30.008 \text{ ms}} = 0.00027 \)$   
    **해석:** 실제 1 Gbps의 링크를 사용하지만, 실질적인 전송률은 267 kbps에 불과함  

**결과:** 송신기가 패킷을 전송한 후 ACK를 기다리는 동안 대기 시간이 길어져, 고속 네트워크 환경에서도 대역폭을 효과적으로 사용하지 못함

### **2. 파이프라이닝(Pipelining) 개념**  
Stop-and-Wait 방식의 문제를 해결하기 위해 `파이프라이닝` 기법 도입  

- **개념:** 송신기가 ACK를 기다리지 않고 **여러 개의 패킷을 연속 전송**하여 전송 파이프라인을 채움  
- **효과:** 동시에 여러 패킷이 송신됨으로써 송신기 이용률이 크게 증가함  
- **요구사항:**   
1. **순서 번호 범위 증가:**  
   - 여러 패킷을 동시에 전송하므로, 각 패킷에는 고유한 순서 번호가 필요함  
2. **버퍼링:**  
   - 송신기: ACK를 받지 않은 패킷을 저장해야 함  
   - 수신기: 도착한 패킷을 순서대로 맞추기 위해 버퍼링이 필요할 수 있음  
3. **오류 복구 전략:**  
   - 데이터 손실, 손상, 지연 상황에서 이를 복구하기 위한 프로토콜이 필요함  

---

## 3.4.3 Go-Back-N (GBN)

### **1. 개념**  
GBN 프로토콜은 **슬라이딩 윈도우 방식**을 사용하여, 송신기가 **최대 N개의 패킷**을 연속 전송할 수 있도록 합니다. 다만, ACK(확인 응답)를 받지 못한 패킷이 **N개를 초과**하면 송신을 중단합니다.
- **윈도우 크기(N):** 송신기가 동시에 보낼 수 있는 패킷 수  
- **누적 ACK:** 수신기는 패킷 `n`에 대한 ACK를 보내며 `n` 이하의 모든 패킷이 수신되었음을 알림  
- **시퀀스 번호:** 패킷에 붙는 고유 번호. 시퀀스 번호는 순환되며 `[0, 2^k - 1]` 범위를 가짐

### **2. 동작 방식**  
1. **송신기**  
   - **패킷 전송:** 윈도우가 가득 차지 않았다면 패킷을 전송  
   - **ACK 수신:** 가장 오래된 패킷부터 순서대로 ACK를 확인 후 윈도우를 이동  
   - **타임아웃:** 특정 패킷의 ACK가 도착하지 않으면 **모든 미확인 패킷**을 재전송  

2. **수신기**  
   - **순서대로 수신:** 패킷이 올바른 순서로 도착하면 상위 계층에 전달하고 ACK 전송  
   - **순서가 틀리거나 손상:** 패킷을 버리고, 마지막으로 정상 수신된 패킷의 ACK를 재전송

### **3. 장점과 단점**  
- **장점:** 구현이 간단하며, 수신기 측 버퍼링이 불필요함  
- **단점:** 패킷 손실 시 모든 미확인 패킷을 재전송하므로 네트워크 효율이 낮아질 수 있음

### **4. GBN 프로토콜 예시**  
- **윈도우 크기:** 4  
- **패킷 전송:** `0`, `1`, `2`, `3` 전송 후 대기  
- **패킷 2 손실 시:** 수신기가 `3`, `4`, `5`를 버림 → 송신기가 `2`부터 다시 전송

### **5. 문제점**
GBN(Go-Back-N) 프로토콜은 여러 패킷을 연속적으로 전송할 수 있지만, **한 패킷이라도 손실되면 해당 패킷 이후의 모든 패킷을 재전송**해야 함  
- **대역폭 낭비:** 단일 패킷 손실로 인해 이미 수신된 패킷을 불필요하게 재전송함  
- **채널 에러 증가 시 비효율성:** 오류 확률이 높을수록 재전송되는 패킷의 양이 많아짐  
  - 예를 들어, 윈도우 크기가 1,000일 경우, 패킷 하나가 손실되면 1,000개 패킷을 재전송해야 함  

**해결해야 할 문제:**  
- 불필요한 재전송을 줄이고 전송 효율을 향상시킬 수 있는 방법 필요

---

## 3.4.4 Selective Repeat (SR) 

### **1. 개념**
Selective Repeat(SR) 프로토콜은 **필요한 패킷만 선택적으로 재전송**하여 불필요한 재전송을 피함  
- **개념:** 손실되거나 손상된 패킷만 개별적으로 재전송함  
- **윈도우 크기 (N):** 송신기가 동시에 전송할 수 있는 패킷의 최대 개수는 N으로 제한됨  

**GBN과의 차이점:**  
- GBN은 누적 ACK 방식 사용 → 손실된 패킷 이후 모든 패킷 재전송  
- SR은 개별 ACK 방식 사용 → 손실된 패킷만 선택적으로 재전송

### **2. 동작 방식**   
#### **SR Sender**  
1. **데이터 전송 요청:**  
   - 상위 계층에서 데이터가 도착하면, 시퀀스 번호가 송신 윈도우 범위 내에 있으면 패킷을 전송.  
   - 시퀀스 번호가 윈도우 범위를 벗어나면 데이터를 버퍼에 저장하거나 상위 계층으로 반환함.  

2. **타임아웃:**  
   - 각 패킷마다 개별적으로 타이머를 설정함.  
   - 특정 패킷이 손실되거나 지연될 경우 해당 패킷만 재전송.  

3. **ACK 수신:**  
   - ACK를 수신하면 해당 패킷을 성공적으로 수신된 것으로 표시함.  
   - `send_base` 값(윈도우의 시작)을 업데이트하여 윈도우를 이동함.  
   - 윈도우 범위 내 전송되지 않은 패킷이 있으면 해당 패킷을 전송.

#### **SR Receiver**  
1. **정상 수신:**  
   - 패킷이 올바르게 수신되면 ACK를 송신기에게 전송.  
   - 패킷이 순서에 맞지 않더라도 일단 버퍼에 저장함.  
   - `rcv_base`(수신 윈도우의 시작)과 일치하는 패킷이 수신되면 버퍼에 저장된 패킷을 순서대로 상위 계층으로 전달함.

2. **중복 패킷 수신:**  
   - 이미 ACK를 보낸 패킷을 다시 수신하면, 중복 ACK를 다시 보냄.

3. **잘못된 패킷 수신:**  
   - 패킷 번호가 수신 윈도우를 벗어나는 경우 패킷을 무시함.

### **3. 장점과 단점**  
- **장점:**  
  - 손실된 패킷만 재전송하므로 대역폭을 효율적으로 사용 가능.  
  - 수신기는 버퍼링을 통해 순서가 맞지 않은 패킷도 처리 가능.  

- **단점:**  
  - 각 패킷마다 개별적인 타이머와 버퍼링이 필요하므로 구현이 복잡함.  
  - 시퀀스 번호 재사용 시 데이터 중복 문제 발생 가능.

#### [참조(GBN/SR Animation)](https://www.tkn.tu-berlin.de/teaching/rn/animations/gbn_sr/)
#### [영상(GBN/SR Animation)](https://www.youtube.com/watch?v=Cs8tR8A9jm8)
