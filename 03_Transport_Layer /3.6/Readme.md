## 3.6 혼잡 제어의 원칙
앞선 손실은 네트워크가 혼잡해짐에 따라 라우터 버퍼가 넘치면서 발생했음. 패킷 재전송은 네트워크 혼잡 증상인 세그먼트 손실은 다루지만, 원인을 해결하진 않음. 
=> 네트워크 혼잡 시 송신자를 제어하는 메커니즘이 필요

#### 3.6.1 혼잡의 원인과 비용
세가지 시나리오를 통해 혼잡이 발생하는 이유와 비용에 대해 살펴보자. 

**시나리오 1: 두 송신자, 무한 버퍼를 가진 라우터**<br>
< 그림 3.43에 나와 있는 것처럼 두 호스트(A와 B)가 각각 소스와 목적지 사이에 단일 홉을 공유하는 연결을 가지고 있다 >
![image](https://github.com/user-attachments/assets/87c85e13-d89c-44df-a9d8-91307e9b3221)


< 그림 3.44 혼잡 시나리오 1: 호스트 전송 속도의 함수로서의 처리량과 지연 >

![image](https://github.com/user-attachments/assets/0cc83e55-e2c5-4465-b564-6cf905c3a1d3)


> 정리
> 1. 라우터가 무한한 버터 공간을 가지고 있더라도 링크 용량(R)의 절반(R/2)을 초과하는 전송 속도에서는 처리량이 R/2로 제한됨
> 2. 전송 속도가 R/2를 초과할 때: 라우터에 많은 패킷이 대기하여 결과적으로 지연 시간이 크게 증가
> 3. 처리량 관점에서는 R에 작동하는 것이 이상적으로 보이지만, 높은 처리량은 큰 지연 시간을 야기하므로 이상적이지 않음.
> > **단순히 처리량을 최대화하는 것이 최선이 아님. 처리량과 지연 시간 사이의 균형을 고려해야 한다**
<br>

---


**시나리오 2: 두 송신자와 유한한 버퍼를 가진 라우터**

1. 라우터 버퍼링의 양이 유한하다고 가정 (이미 가득 찬 버퍼에 도착하는 패킷은 버려질 것)
2. 각 연결이 신뢰할 수 있다 가정
![image](https://github.com/user-attachments/assets/a1778908-f0f3-4a10-8f26-e73d2f4b513b)



< 그림 3.45 시나리오 2: 두 호스트(재전송 포함)와 유한한 버퍼를 가진 라우터 >
![image](https://github.com/user-attachments/assets/b80630f3-1baf-44bc-97e4-bc277e3ef605)

> 정리<br>
> a) 이상적인 경우: 버퍼가 비어있을 때만 패킷을 보내서 모든 패킷이 수신되고 재전송이 필요 없음. 하지만 이는 현실적으로 불가능<br>
> b) 패킷 손실과 재전송: 실제 전송 속도는 R/3이며, 일부 데이터가 손실되어 재전송이 필요<br>
> c) 불필요한 재전송: 손실되지 않은 패킷이 재전송되어 원본과 재전송본이 모두 수신자에게 도착. 이로 인해 패킷 중복과 라우터의 대역폭 낭비가 발생<br>



---

**시나리오 3: 네 개의 송신자, 유한한 버퍼를 가진 라우터, 그리고 다중 홉 경로**

< 그림 3.47 네 개의 송신자, 유한한 버퍼를 가진 라우터, 그리고 다중 홉 경로 >

< 그림 3.48 유한한 버퍼와 다중 홉 경로를 가진 시나리오 3의 성능 >


> 정리
> 부하가 증가함에 따라 결국 처리량이 감소하는 이유는
> 패킷이 두 번째 홉 라우터에서 버려질때마다, 첫 번째 홉 라우터가 패킷을 두번째 홉 라우터로 전달하는 작업은 결국 "낭비"가 됨.
> 첫 번째 라우터에서 패킷을 전달하는 데 사용된 전송 용량이 다른 패킷을 전송하는 데 훨씬 더 유용하게 사용될 수 있었음.
> 

