## 3.6 혼잡 제어의 원칙
앞선 손실은 네트워크가 혼잡해짐에 따라 라우터 버퍼가 넘치면서 발생했음. 패킷 재전송은 네트워크 혼잡 증상인 세그먼트 손실은 다루지만, 원인을 해결하진 않음. 
=> 네트워크 혼잡 시 송신자를 제어하는 메커니즘이 필요

#### 3.6.1 혼잡의 원인과 비용
세가지 시나리오를 통해 혼잡이 발생하는 이유와 비용에 대해 살펴보자. 

**시나리오 1: 두 송신자, 무한 버퍼를 가진 라우터**<br>
< 그림 3.43에 나와 있는 것처럼 두 호스트(A와 B)가 각각 소스와 목적지 사이에 단일 홉을 공유하는 연결을 가지고 있다 >
![image](https://github.com/user-attachments/assets/87c85e13-d89c-44df-a9d8-91307e9b3221)


< 그림 3.44 혼잡 시나리오 1: 호스트 전송 속도의 함수로서의 처리량과 지연 >

![image](https://github.com/user-attachments/assets/0cc83e55-e2c5-4465-b564-6cf905c3a1d3)


> 정리
> 1. 라우터가 무한한 버터 공간을 가지고 있더라도 링크 용량(R)의 절반(R/2)을 초과하는 전송 속도에서는 처리량이 R/2로 제한됨
> 2. 전송 속도가 R/2를 초과할 때: 라우터에 많은 패킷이 대기하여 결과적으로 지연 시간이 크게 증가
> 3. 처리량 관점에서는 R에 작동하는 것이 이상적으로 보이지만, 높은 처리량은 큰 지연 시간을 야기하므로 이상적이지 않음.
> > **단순히 처리량을 최대화하는 것이 최선이 아님. 처리량과 지연 시간 사이의 균형을 고려해야 한다**
<br>

---


**시나리오 2: 두 송신자와 유한한 버퍼를 가진 라우터**

1. 라우터 버퍼링의 양이 유한하다고 가정 (이미 가득 찬 버퍼에 도착하는 패킷은 버려질 것)
2. 각 연결이 신뢰할 수 있다 가정
![image](https://github.com/user-attachments/assets/a1778908-f0f3-4a10-8f26-e73d2f4b513b)



< 그림 3.45 시나리오 2: 두 호스트(재전송 포함)와 유한한 버퍼를 가진 라우터 >
![image](https://github.com/user-attachments/assets/b80630f3-1baf-44bc-97e4-bc277e3ef605)

> 정리<br>
> a) 이상적인 경우: 버퍼가 비어있을 때만 패킷을 보내서 모든 패킷이 수신되고 재전송이 필요 없음. 하지만 이는 현실적으로 불가능<br>
> b) 패킷 손실과 재전송: 실제 전송 속도는 R/3이며, 일부 데이터가 손실되어 재전송이 필요<br>
> c) 불필요한 재전송: 손실되지 않은 패킷이 재전송되어 원본과 재전송본이 모두 수신자에게 도착. 이로 인해 패킷 중복과 라우터의 대역폭 낭비가 발생<br>



---

**시나리오 3: 네 개의 송신자, 유한한 버퍼를 가진 라우터, 그리고 다중 홉 경로**

< 그림 3.47 네 개의 송신자, 유한한 버퍼를 가진 라우터, 그리고 다중 홉 경로 >
![image](https://github.com/user-attachments/assets/7dc43634-68eb-4b42-9e99-682a6810dc40)

< 그림 3.48 유한한 버퍼와 다중 홉 경로를 가진 시나리오 3의 성능 >
![image](https://github.com/user-attachments/assets/8fce3c32-8803-4284-9862-6fba95360cb7)


> 정리<br>
> 패킷이 두 번째 홉 라우터에서 버려질때마다, 첫 번째 홉 라우터가 패킷을 두번째 홉 라우터로 전달하는 작업은 결국 "낭비"가 됨.<br>
> 첫 번째 라우터에서 패킷을 전달하는 데 사용된 전송 용량이 다른 패킷을 전송하는 데 훨씬 더 유용하게 사용될 수 있었음.<br>
> 혼잡으로 인한 패킷 손실의 추가적 비용(그 패킷을 버리는 지점까지 전달하는데 사용된 링크의 전송 용량이 낭비됨)<br>
> > **네트워크의 용량(R)에 비해 제공된 부하(λin)가 너무 커지면 오히려 성능(처리량)이 저하**


---

### 3.6.2 혼잡 제어에 대한 접근 방식
실제로 사용되는 두 가지 혼잡 제어 접근 방식을 확인하자

**1. End-to-end congestion control(종단 간 혼잡 제어):**
   - 네트워크 자체는 혼잡에 대한 직접적인 정보를 제공하지 않는다
   - 종단 시스템이 패킷 손실이나 지연 같은 징후를 통해 혼잡을 추론함
   - TCP가 사용하는 방식
   
**2. Network-assisted congestion control(네트워크 지원 혼잡 제어):**
   - 네트워크의 라우터가 혼잡 상태에 대한 명시적 정보를 제공
   - 간단한 혼잡 표시부터 상세한 전송 속도 정보까지 다양한 수준의 피드백이 가능
   - 일부 특수 네트워크 아키텍처에서 사용

IP와 TCP는 혼잡 제어에 대해 종단 간 접근 방식을 채택하지만, 최근에는 선택적으로 네트워크 지원 혼잡 제어를 구현할 수 있다. (3.7.2절)

   네트워크 지원 혼잡 제어의 경우, 그림 3.49에 나와있는 두 가지 장법 중 하나로 네트워크에서 송신자에게 피드백된다.
   ![image](https://github.com/user-attachments/assets/8f3c8f7b-69c6-4891-b0fc-ae46a66c5c50)

**1. Direct network feedback (직접 네트워크 피드백):**
  - 네트워크의 라우터가 송신자(Host A)에게 직접 혼잡 정보를 전송(초크 패킷)
  - 더 빠른 피드백이 가능함
    
**2. Network feedback via receiver (수신자를 통한 네트워크 피드백):**
  - 라우터가 패킷에 혼잡 정보를 표시
  - 수신자(Host B)가 이 정보를 확인한 후 송신자에게 다시 전달
  - 완전한 왕복 시간이 필요함


---

> ### 전체 내용 정리
> 
> #### 시나리오 2를 통해 버퍼 오버플로우, 패킷 손실과 재전송, 대역폭 낭비
>
> #### 시나리오 3을 통해 용량에 비해 부하가 너무 크면 처리량이 작아지는 TRADE-OFF
>
> #### 혼잡 제어 방식에는 종단 간 방식과 네트워크 지원 방식이 있다.



