
## 1.4 Delay, Loss, and Throughput in Packet-Switched Networks
- 인터넷은 최종 시스템에서 실행되는 분산 애플리케이션에 서비스를 제공하는 인프라
- 이상적으로는 두 개의 최종 시스템 간에 원하는 만큼의 데이터를 즉시, 손실없이 전송하기를 바랬음.
- 하지만 현실에서는 할수없는 목표임.
  - 시스템 간의 처리량
  - 시스템 간 지연
- 따라서 패킷을 손실 시킬 수 있음.

### 1.4.1 Overview of Delay in Packet-Switched Networks
- 패킷은 호스트(전송자)에서 라우터를 거쳐서 다른 호스트(목적지)로 이동함
- 패킷이 경로상의 한 노드에서 다음 노드 이동시 지연 겪게 됨
- 처리 지연, 대기 지연, 전송 지연, 전파 지연이 있음
- 
####  1) Processing Delay
- 패킷의 헤더를 검사하고 패킷을 어디로 보낼지 결정하는 데 필요한 시간은 처리 지연의 일부
- 처리 지연은 또한 패킷 비트 전송 중 발생한 비트 수준 오류를 검사하는 데 필요한 시간 등 다른 요소도 포함.
- 고속 라우터에서의 처리 지연은 일반적으로 마이크로초 단위임.
- 노드 처리가 끝난 후 라우터는 패킷을 라우터 B로 가는 링크 앞의 대기열로 안내함.
![image](https://github.com/user-attachments/assets/4efc0788-d57b-496d-9ad9-155799b97cd2)


####  2) Queuing Delay
- 대기열에서 패킷은 링크로 전송되기를 기다리면서 대기 지연을 겪음
- 특정 패킷의 대기 지연 길이는 전송을 기다리는 이전에 도착한 패킷의 수에 따라 달라짐
- 대기열이 비어 있고 현재 전송 중인 패킷이 없다면, 패킷의 대기 지연은 0이 됨
- 반면, 트래픽이 많고 많은 다른 패킷이 전송을 기다리고 있다면 대기 지연은 길어짐.
- 대기 지연은 실제로 마이크로초에서 밀리초 단위임.

####  3) Transmission Delay
- 패킷이 선착순으로 전송된다고 가정할 때, 패킷은 자신보다 먼저 도착한 모든 패킷이 전송된 후에만 전송될 수 있음.(큐 이기 때문에 FIFO)
- 패킷의 길이를 𝐿 비트로, 라우터 A에서 라우터 B로의 링크 전송 속도를 R 비트/초로 나타내면, 전송 지연은 𝐿/𝑅 L/R로 계산된다. 이를테면 10 Mbps 이더넷 링크의 경우 전송 속도는 R = 10 Mbps임

#### 4) Propagation Delay
- 비트가 링크에 전송되면, 그 비트는 라우터 B로 전파됨.
- 링크의 시작점에서 라우터 B까지 전파되는 데 필요한 시간은 전파 지연임
- 전파 지연은 두 라우터 간의 거리 d를 전파 속도 s로 나눈 값입니다. 즉, 전파 지연은 𝑑/𝑠로 표현됨

#### Comparing Transmission and Propagation Delay
- 전파지연과 전송지연은 아예 다름
![image](https://github.com/user-attachments/assets/d802b733-d3ff-4b8b-89e1-3370cdea5281)
- 전송지연은 t2 - t1 = L / C = 패킷의 크기/ 링크의 용량 으로 링크의 용량을 파이프의 크기 라고 생각하면됨
- 데이터가 클때 전송지연이 커지게됨. 배수관을 생각하면 된다.
- 전파 지연은 t3 - t1 = t4 - t2 =  D / 전파속도
- 연못에 돌 던지면 물이 퍼져나가는 속도 라도 이해하면 됨

#### 결론
총 노드 지연은 총 노드 지연은 다음과 같이 표현됨
𝑑 nodal = 𝑑 proc + 𝑑 queue + 𝑑 trans + 𝑑 prop

### 1.4.2 Queuing Delay and Packet Loss
- 대기 지연이 크게 발생하는 경우와 무시할 수 있는 경우는 언제일까?
- 대기열에 도착하는 트래픽의 속도, 링크의 전송 속도, 그리고 도착하는 트래픽의 성격(주기적으로 도착하는지, 급격히 도착하는지)에 따라 달라짐.
- 여기서 패킷이 대기열에 도착하는 평균 속도를 λ (패킷/초)로 정의할때 R은 전송 속도로, 대기열에서 비트가 전송되는 속도(비트/초)임. 모든 패킷이 L 비트로 구성되어 있다고 가정하면, 대기열에 도착하는 비트의 평균 속도는 Lλ 비트/초
- 대기열이 매우 크다고 가정하면, 사실상 무한한 비트를 저장할 수 있음.
- 비율 Lλ/R, 즉 트래픽 강도는 대기 지연을 추정하는 데 중요한 역할을 하는데 이 Lλ/R > 1이면 비트 평균 속도 > 비트 전송 평균 속도가 되므로 나가는거 보다 들어 오는게 많으므로 대기 지연이 후에 무한에 가까워짐
- 따라서 Lλ/R이 1보다 작게 유지하는게 중요
- Lλ/R이 < 1 인 경우에선 L/R 초마다 패킷이 도착하므로 처음은 패킷지연 없음 2번째는 L/R초 n번째는 (n - 1)L/R의 패킷지연을 겪게됨
![image](https://github.com/user-attachments/assets/28e1a7bf-73ec-49a8-82b1-25fd2e9e6135)

#### 패킷손실
- 대기열이 가득차 있을 때 대기열의 저장 공간보다 더 패킷이 들어오면 패킷을 버리게 됨 이걸 대기열의 오버플러우 라고 하고 트래픽강도가 1이상일때 일어남


### 1.4.3 End-to-End Delay
- 출발지 호스트와 목적지 호스트 사이에 𝑁−1개의 라우터가 있다고 가정해 하고 또한, 네트워크가 혼잡하지 않다고 가정하고(대기 지연이 무시할 수 있을 정도로 작다고 가정)
- 각 라우터 및 출발지 호스트에서의 처리 지연은 d proc, 각 라우터와 출발지 호스트의 전송 속도는 R 비트/초, 각 링크에서의 전파 지연은 𝑑 prop라고 가정함
- d end-to-end = N(d proc + d trans +d prop)
​
### 1.4.4 Throughput in Computer Networks
- 지연과 패킷 손실 외에, 컴퓨터 네트워크에서 또 다른 중요한 성능 측정 지표는 종단 간 처리량
![image](https://github.com/user-attachments/assets/46833f8a-fe39-4bf6-9060-d07ec68b9654)
- 위 그림에서 Rs 는 서버와 라우터간의 링크 속도, Rc는 라우터와 클라이언트 간의 링크속도임. 서버 -> 클라이언트 로만 비트 전송한다고 가정함
- 통신링크(파이프) 비트(물) 이렇게 생각하면 Rs <= Rc면 처리량은 Rs
- Rc <= Rs인 경우에는 Rc이다 이때 문제는 클라이언트에서 대기 중인 비트의 적채가 계속 증가하게됨.
- 이를테면 서버에서 클라로 F 비트를 전송하는데 거리는 시간은 근사(F/min{Rs, Rc}) 이다.
- 2개 보다 많을 경우에는 일반화 하면 min{R 1,R 2,…,R N} 같은 식이 됨
