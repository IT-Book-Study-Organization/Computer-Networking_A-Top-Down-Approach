## 5.2.2 The Distance-Vector (DV) Routing Algorithm

**Distance Vector (DV) Routing Algorithm** : **반복적(iterative), 비동기적(asynchronous), 분산적(distributed)** 알고리즘
  - 각 노드는 인접 노드로부터 정보를 수집하고 계산한 후 이를 다시 인접 노드로 전파함
  - 더 이상 정보가 교환되지 않을 때까지 반복되며, 별도의 종료 신호 없이 자동으로 종료됨

**Bellman-Ford 방정식** : 최소 비용 경로의 관계를 정의

```math
d_x(y) = min_v [ c(x, v) + d_v(y) ]
```

- $d_x(y)$: 노드 $x$에서 노드 $y$까지의 최소 비용 경로 비용
- $c(x, v)$: 노드 $x$에서 인접 노드 $v$까지의 비용
- $d_v(y)$: 노드 $v$에서 노드 $y$까지의 최소 비용 경로 비용
- $\min_v$: $x$의 모든 인접 노드 $v$에 대해 최소값을 선택

### 예제 (Figure 5.3)
$$
d_v(z) = 5, \quad d_x(z) = 3, \quad d_w(z) = 3
$$

$$
c(u, v) = 2, \quad c(u, x) = 1, \quad c(u, w) = 5
$$

$$
d_u(z) = \min(2 + 5, 5 + 3, 1 + 3) = 4
$$

**Dijkstra 알고리즘과 동일한 결과를 나타냄**

- **Distance Vector (DV) Routing Algorithm**의 `x`는 다음과 같은 **Distance Vector**를 유지함

$$
D_x = [ D_x(y) : y \in N ]
$$

- 즉, $D_x(y)$는 노드 $x$에서 모든 다른 노드 $y$까지의 최소 비용 경로를 나타내는 벡터

### 예시

각 노드 `x`는 다음과 같은 정보를 유지

- **각 이웃 `v`에 대한 비용**: $c(x, v)$, `x`에서 직접 연결된 이웃 `v`로의 비용

- **노드 `x`의 거리 벡터**: $D_x = [D_x(y): y ∈ N]$, `x`에서 네트워크 내 모든 목적지 `y`까지의 비용 추정치

- **각 이웃 `v`의 거리 벡터**: $D_v = [D_v(y): y ∈ N]$, `x`의 이웃 `v`로부터 받은 거리 벡터


$c(x, v)$ : 노드 `x`에서 직접 연결된 이웃 `v`로의 비용

$D_x$ : 노드 `x`가 모든 목적지로 도달하는 데 드는 비용 추정치를 담은 벡터

$D_v$ : 노드 `x`의 이웃 `v`로부터 받은 거리 벡터 (네트워크의 모든 목적지 비용 정보 포함)


### 거리 벡터 수신 및 업데이트 :
   - 노드 `x`는 이웃 `w`로부터 새로운 거리 벡터 $D_w$를 받으면 저장
   - 이후 Bellman-Ford 방정식을 사용하여 자신의 거리 벡터를 업데이트
     
     $$D_x(y) = \min_v \{ c(x, v) + D_v(y) \},$$ for each node y in $N$

### Distance-Vector (DV) Algorithm CODE

![image](https://github.com/user-attachments/assets/13798141-ecb9-4a42-a85c-a34d26b4ceca)

![image](https://github.com/user-attachments/assets/83e42e13-1a21-422a-aac3-6a5a8e74addd)

![image](https://github.com/user-attachments/assets/2f9a1072-2a21-4ef0-b38d-6a428c4c8ce9)

---

![image](https://github.com/user-attachments/assets/de69cd2b-2b04-4419-9cf5-8f80b00b9b71)

- 화살표는 노드 간 거리 벡터가 전송되는 과정

### 초기 상태 (왼쪽 첫 번째 열)
- 각 노드는 자신의 초기 거리 벡터를 계산하고, 이웃 노드로부터 받은 값은 무한대(∞)로 설정
- **Node x**:
    ```
    cost to
    x   y   z
    0   2   7
    ∞   ∞   ∞
    ∞   ∞   ∞
    ```
    - 첫 번째 행은 노드 `x`의 거리 벡터 $\( D_x = [0, 2, 7] \)$
    - 두 번째와 세 번째 행은 이웃 노드 `y`와 `z`로부터 아직 받은 정보가 없기 때문에 초기화 값이 ∞
 
### 업데이트 단계
- 각 노드는 자신의 거리 벡터를 이웃 노드로 전송
- **Node x**는 $\( D_x = [0, 2, 7] \)$를 `y`와 `z`로 전송
- 이웃 노드들은 수신한 정보를 기반으로 거리 벡터를 업데이트

### 중간 상태 (두 번째 열)
- 이웃 노드로부터 받은 거리 벡터를 바탕으로 Bellman-Ford 방정식을 사용해 업데이트:
  
$$
D_x(y) = \min \[ c(x, y) + D_y(y), c(x, z) + D_z(y) \]
$$
- **Node x**:
    ```
    cost to
    x   y   z
    0   2   3
    2   0   1
    7   1   0
    ```
    - $D_x(z)는 \( \min \[ c(x, y) + D_y(z), c(x, z) + D_z(z) \] = \min \[ 2 + 1, 7 + 0 \] = 3 \)$
 
### 최종 상태 (오른쪽 열)

- 모든 노드가 안정화되고 최단 경로를 계산:
- **Node x**:
    ```
    cost to
    x   y   z
    0   2   3
    2   0   1
    7   1   0
    ```
- 각 노드가 최단 경로를 기준으로 업데이트된 거리 벡터를 보유
