## 5.2 라우팅 알고리즘
라우팅 알고리즘은 발신자에서 수신자로 가는 최적의 경로(최소 비용 경로)를 찾는 것임. 실제로는 정책적 문제도 고려해야함.

#### 그래프 모델
- 그래프 G = (N, E)에서 (노드 집합 N: 라우터, 엣지 집합 E: 물리적 링크)
- 엣지 비용: 각 엣지 (x, y)에 대해 비용을 c(x, y)로 정의함. 만약에 (x, y)가 E에 속하지 않으면 c(x, y) = ∞ 로 설정함.
- 방향 없는 그래프를 고려하여, c(x, y) = c(y, x)임 만약 방향성 링크의 경우에는 c(x, y) != c(y, x) 일 가능성 있음.

#### 경로 및 비용
- 경로는 노드의 시퀸스 (x1, x2, ..., xp)로 정의되며, 각 쌍 (xi, xi+1) ∈ E임.
- 경로의 비용은 다음과 같이 계산됨 Cost(x1, x2, ... , xp) = c(x1, x2) + c(x2, x3) + ... + c(xp-1, xp)
- 두 노드 간에는 여러 경로가 있을 수 있으며, 이들 중 하나 이상이 최소 비용 경로가 됨.

#### 최소 비용 문제
- 출발지와 목적지 간의 최소 비용을 찾는게 목적임.
- ![image](https://github.com/user-attachments/assets/d4d6eb7d-789a-4587-b60f-7de3167e9d6a)
- 위 그림에서 최소 비용 경로는 (u,x, y, w)이며, 경로 비용은 3임.

#### 라우팅 알고리즘의 특징
- 모든 엣지가 동일한 비용을 가진 경우, 최소 비용 경로는 "링크 수가 가장 적은 경로"가 됨

#### 라우팅 알고리즘 분류
- 중앙 집중식 vs 분산식:
    - 중앙집중식 : 전체 네트워크 정보를 사용하여 최소 비용 경로를 계산. 링크 상태(LS) 알고리즘이 이것임.
    - 분산식 : 각 노드가 이웃과 정보를 교환하여 최소 비용 경로를 계산. 거리 벡터(DV) 알고리즘이 여기에 해당.
- 정적 vs 동적:
    - 정적: 경로가 느리게 변하며 인간의 개입으로 조정됨.
    - 동적: 네트워크 변화에 따라 경로가 실시간으로 조정됨
- 부하 민감 vs 부하 무관:
    - 부하 민감: 링크 비용이 현재 혼잡도를 반영하여서 동적으로 변환
    - 부하 무관: 링크 비용이 고정되어 있으며 현재의 혼잡도와 관계없이 적용됨.
 
### 링크 상태 알고리즘
- 네트워의 토폴로지와 모든 링크 비용이 알고리즘의 입력으로 사용됨.
- 각 노드가 링크 상태 패킷을 네트워크의 모든 다른 노드에 브로드캐스트 하여 이 정보를 전달
- 이를테면 인터넷의 OSPF 라우팅 프로토콜은 이러한 링크 상태 브로드캐스트 알고리즘을 사용해여 이를 수행함.

#### 다익스트라 알고리즘
- 링크 상태 알고리즘은 다익스트라 알고리즘임, 다익스트라 알고리즘은 소스 노드에서 네트워크의 모든 다른 노드까지 최소 비용 경로를 계산함.
- D(v) : 소스 노드에서 목적지 v까지의 최소 비용 경로 비용
- P(v) : 현재 최소 비용 경로에서 v의 이전 노드(이웃 노드)
- N : 노드의 부분 집합; v가 N에 포함되면, 소스에서 v까지의 최소 비용 경로가 확정적으로 알려져 있음.
![image](https://github.com/user-attachments/assets/880f465f-4083-4901-8239-cdf2d47e67bf)
(출처: https://velog.io/@kms9887/%EC%BB%B4%ED%93%A8%ED%84%B0-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-45.-Network-Layer)
![image](https://github.com/user-attachments/assets/29f6a8de-2442-492e-8351-34dda208e8d9)
(출처: https://velog.io/@kms9887/%EC%BB%B4%ED%93%A8%ED%84%B0-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-45.-Network-Layer)
![image](https://github.com/user-attachments/assets/0340eca7-67fd-4f18-a35b-627db719c625)
(출처: https://velog.io/@kms9887/%EC%BB%B4%ED%93%A8%ED%84%B0-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-45.-Network-Layer)
##### 수도코드
![image](https://github.com/user-attachments/assets/249e9ba4-3d84-4606-83aa-fa155d8bfea7)
- Initialization : N' = { u } ## N' 집합을 정희함 { u } 모든 노드를 돌다가 v가 u의 이웃이면 D(v) = c(u, v) 라고 하고 이웃이 아니면 D(v) = infinity라고 함
- Loop : N' 속하지 않는 D(w)가 최소가 되게하는 w를 찾는다. 그것을 N'집합에 넣고 N'에 속하지 않고 w의 이웃인 v에 대해서 D(v)을 업데이트 한다. D(v)와 D(w) + c(w,v) 중 최솟값을 고름 다시 말해 바로 v로 가는 것과 w를 거쳐서 v로 가는 것중 최소를 고름 N`이 모든 네트워크 N와 같아 질 때까지 반복함.

![image](https://github.com/user-attachments/assets/3d03fb29-68d4-4dc4-9a22-009476388398)
- step 0에서는 N'안에 u뿐 이므로 u와 직접적으로 연결된 v, w, x만 보고 거리를 알아냄.
- step 1에서는 N'아넹 u,x 이므로 v로 가는 비용은 위와 같고 w로 가는 비용이 x를 거쳐서 가는데 더 적으므로 4, x 로 바뀜. y로 바는 것은 x로 갈 때 연결되므로 2, x가 됨.
- step 2에서는 N'안에 u,x,y 이므로 v로 가는 비용은 위와 같고 w로 가는 비용이 x를 y를 거쳐서 가는게 더 적으므로 3, y 로 바뀜. x,y 둘다 N'에 있으므로 굳이 계산 필요 x 그냥 0임 비용, z로 가는 길 생김 y덕분에
- step 3에서는 N'안에 u,x,y,v 이므로 v로 가는 비용은 0임 w로 가는 비용은 동일 z로 가는 비용도 동일
- step 4에서는 z로 가는 비용만 고려 근데 같음
- step 5에서는 모든 N의 노드가 N'에 있으므로 알아볼 필요 X

#### 링크 상태 알고리즘 비용분석
- 반복 분석
  - 첫번째 반복에서 n 노드를 모두 검색해서 순회돔
  - 두번째 반복에서 n-1 돔
  - ... 이렇게 n번가면 n + (n - 1) + (n - 2) + .... + 1 이렇게 되고 n(n+1)/2이 됨 그래서 최악 시간 복잡도 O(n^2) 가됨
  - 근데 힙으로 어떻게 잘하면 O(nlogn)으로 된다고 함. 이유는... 잘모르겠음


#### 링크 비용 네트워크에서의 병리현상
![image](https://github.com/user-attachments/assets/8cdb9873-d69c-4b3f-ab6e-57bc573cedeb)
- 첫번째로 할떄 y가 시계 방향 경로 비용이 1인데, 반시계는 1 + e임 그거 보고 y는 방향을 시계로 바꿈, 노드 x도 마찬가지로 시계방향으로 바꿈
- 두번째로 할때 LS 알고리즘 실행 시, (x, y, z)는 반시계 방향으로 w에 대한 0비용을 감ㅁ지하고 모든 반시계로 라우팅함. 근데 또 LS 알고리즘을 실행시키면 다시 시계로 바꿈 이걸 진동한다 라고함.
- 해결방안으로는 스케줄링된 실행을 하는게 있는데 모든노드가 동시에 LS 알고리즘 실행하지 않게 하는 것이다.
- 무작위화 라는 방법도 있는데 스케줄링을 해도 자가 동기화가 된다고 한다. 노드들이 그래서 전송 시간 자체를 무작위로 한다.


