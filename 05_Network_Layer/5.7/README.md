# 5.7 Network Management and SNMP, NETCONF/YANG
이제 네트워크 계층에 대한 학습을 마치고, 링크 계층만을 앞두고 있는 시점에서 우리는 네트워크가 수많은 복잡한 하드웨어와 소프트웨어가 상호 작용하는 요소들로 구성된다는 것을 잘 알고 있습니다. 네트워크의 물리적 구성 요소를 이루는 링크, 스위치, 라우터, 호스트 및 기타 장치부터 이러한 장치를 제어하고 조정하는 다양한 프로토콜에 이르기까지 모두 포함됩니다. 이러한 수백 또는 수천 개의 구성 요소가 한 조직에 의해 네트워크로 결합될 때, 네트워크 관리자가 네트워크를 “정상적으로 운영”하는 일은 분명히 도전 과제가 됩니다. 5.5절에서 논의했듯이, 논리적으로 중앙 집중화된 컨트롤러는 SDN 환경에서 이 과정을 돕는 역할을 할 수 있습니다. 그러나 네트워크 관리는 SDN이 등장하기 훨씬 이전부터 존재해왔으며, 네트워크 관리자가 네트워크를 모니터링, 관리 및 제어하는 데 도움을 주는 다양한 네트워크 관리 도구와 접근 방식이 발전해왔습니다. 우리는 이 절에서 이러한 도구와 기술뿐만 아니라 SDN과 함께 공동 발전한 새로운 도구와 기술도 연구할 것입니다.  

자주 묻는 질문 중 하나는 “네트워크 관리란 무엇인가?”입니다. [Saydam 1996]에서 제시한 잘 구성된 한 문장(비록 상당히 긴 문장이지만)의 정의는 다음과 같습니다:  

네트워크 관리는 하드웨어, 소프트웨어 및 인적 요소의 배포, 통합 및 조정을 포함하며, 실시간 운영 성능 및 합리적인 비용으로 품질(Quality of Service) 요구 사항을 충족하기 위해 네트워크 및 요소 자원을 모니터링, 테스트, 폴링, 구성, 분석, 평가 및 제어하는 것을 의미합니다.  

이러한 광범위한 정의를 고려할 때, 우리는 이 절에서 네트워크 관리의 기초만을 다룰 것입니다. 즉, 네트워크 관리자가 작업을 수행하는 데 사용하는 아키텍처, 프로토콜 및 데이터에 초점을 맞출 것입니다. 우리는 관리자들의 의사 결정 과정에 대해서는 다루지 않을 것입니다. 여기에는 장애 식별 [Labovitz 1997; Steinder 2002; Feamster 2005; Wu 2005; Teixeira 2006], 이상 탐지 [Lakhina 2005; Barford 2009], 계약된 서비스 수준 계약(SLA, Service Level Agreement)을 충족하기 위한 네트워크 설계/엔지니어링 [Huston 1999a] 등의 주제가 포함됩니다. 따라서 우리의 초점은 의도적으로 좁혀져 있으며, 관심 있는 독자는 이러한 참고 문헌과 [Subramanian 2000; Schonwalder 2010; Claise 2019]에서 제공하는 훌륭한 개요를 참조하거나 이 텍스트의 웹사이트에서 제공하는 보다 상세한 네트워크 관리 자료를 확인할 수 있습니다.

## 5.7.1 The Network Management Framework
그림 5.20은 네트워크 관리의 주요 구성 요소를 보여줍니다.  

- **관리 서버(Managing server)**:  
  관리 서버는 일반적으로 네트워크 운영 센터(NOC, Network Operations Center)의 중앙 집중식 네트워크 관리 스테이션에서 실행되는 애플리케이션으로, 네트워크 관리자(사람)가 개입하는 경우가 많습니다. 관리 서버는 네트워크 관리 활동의 중심으로, 네트워크 관리 정보와 명령의 수집, 처리, 분석 및 배포를 제어합니다. 네트워크의 관리 대상 장치를 구성, 모니터링 및 제어하는 작업이 여기서 시작됩니다. 실제로 하나의 네트워크에는 여러 개의 관리 서버가 있을 수 있습니다.  

- **관리 대상 장치(Managed device)**:  
  관리 대상 장치는 관리되는 네트워크 내에 존재하는 네트워크 장비(및 그 소프트웨어)입니다. 관리 대상 장치는 호스트, 라우터, 스위치, 미들박스, 모뎀, 온도계 또는 기타 네트워크에 연결된 장치일 수 있습니다. 장치 자체에는 여러 관리 가능한 구성 요소(예: 호스트 또는 라우터의 네트워크 인터페이스 하나)와 이 하드웨어 및 소프트웨어 구성 요소의 설정 매개변수(예: OSPF 같은 내부 AS 라우팅 프로토콜)가 포함됩니다.  

- **데이터(Data)**:  
  각 관리 대상 장치는 해당 장치와 연관된 데이터(또는 “상태(state)”)를 가지고 있습니다. 여러 유형의 데이터가 존재합니다.  
  - **구성 데이터(Configuration data)**: 네트워크 관리자가 명시적으로 구성한 장치 정보입니다. 예를 들어, 관리자가 지정한 IP 주소 또는 장치 인터페이스의 속도 설정이 이에 해당합니다.  
  - **운영 데이터(Operational data)**: 장치가 작동하면서 얻는 정보입니다. 예를 들어, OSPF 프로토콜에서 직접 연결된 이웃 목록이 포함될 수 있습니다.  
  - **장치 통계(Device statistics)**: 장치가 작동하면서 업데이트되는 상태 표시기 및 카운트 값입니다. 예를 들어, 인터페이스에서 손실된 패킷 수 또는 장치의 냉각 팬 속도 등이 이에 해당합니다.  
  네트워크 관리자는 원격 장치 데이터를 조회할 수 있으며, 경우에 따라 아래에서 설명할 방식으로 원격 장치의 데이터를 변경할 수도 있습니다. 그림 5.17에서 볼 수 있듯이, 관리 서버는 또한 관리 대상 장치에서 수집된 구성 데이터, 운영 데이터 및 통계 데이터를 유지하며, 네트워크의 전체적인 데이터(예: 네트워크의 토폴로지)도 저장합니다.  

- **네트워크 관리 에이전트(Network management agent)**:  
  네트워크 관리 에이전트는 관리 대상 장치에서 실행되는 소프트웨어 프로세스로, 관리 서버와 통신하며 관리 서버의 명령 및 제어 하에 로컬 장치에서 동작을 수행합니다. 네트워크 관리 에이전트는 그림 5.2에서 본 라우팅 에이전트와 유사합니다.  

- **네트워크 관리 프로토콜(Network management protocol)**:  
  네트워크 관리 프레임워크의 마지막 구성 요소는 네트워크 관리 프로토콜입니다. 이 프로토콜은 관리 서버와 관리 대상 장치 간에 실행되며, 관리 서버가 관리 대상 장치의 상태를 조회하고 해당 장치의 에이전트를 통해 특정 작업을 수행할 수 있도록 합니다. 또한, 에이전트는 네트워크 관리 프로토콜을 사용하여 관리 서버에 예외적인 이벤트(예: 구성 요소 고장 또는 성능 임계값 초과)를 알릴 수도 있습니다.  

  중요한 점은 **네트워크 관리 프로토콜 자체가 네트워크를 직접 관리하지는 않는다는 것입니다**. 대신, 이 프로토콜은 네트워크 관리자가 네트워크를 관리(“모니터링, 테스트, 폴링, 구성, 분석, 평가 및 제어”)할 수 있는 기능을 제공합니다. 이는 미묘하지만 중요한 차이점입니다.  

### **실무에서 네트워크 운영자가 네트워크를 관리하는 세 가지 주요 방식**  

위에서 설명한 구성 요소를 사용하여 네트워크 운영자는 일반적으로 세 가지 방식으로 네트워크를 관리할 수 있습니다.  

1. **CLI(Command Line Interface, 명령줄 인터페이스)**  
   - 네트워크 운영자는 장치에 직접 **CLI 명령을 입력**하여 명령을 실행할 수 있습니다.  
   - 이러한 명령은 관리 대상 장치의 콘솔에서 직접 입력할 수도 있고, Telnet 또는 보안 셸(SSH) 연결을 통해 원격으로 입력할 수도 있습니다.  
   - CLI 명령어는 **벤더 및 장치별**로 다르며, 상당히 난해할 수 있습니다.  
   - 숙련된 네트워크 관리자는 CLI를 사용하여 네트워크 장치를 정확하게 구성할 수 있지만, **CLI는 오류 발생 가능성이 높고 자동화가 어렵기 때문에 대규모 네트워크에서는 비효율적**입니다.  
   - 소비자용 네트워크 장치(예: 가정용 무선 라우터)는 웹 인터페이스(HTTP)를 통해 관리 메뉴를 제공하기도 합니다.  
   - 이러한 방식은 단일 장치를 관리하는 데는 유용하지만, 대규모 네트워크에는 적합하지 않습니다.  

2. **SNMP/MIB(Simple Network Management Protocol / Management Information Base)**  
   - 이 방법에서는 **SNMP 프로토콜**을 사용하여 장치의 **관리 정보 데이터베이스(MIB) 객체**를 조회/설정할 수 있습니다.  
   - 일부 MIB는 **벤더 및 장치별**로 다르지만,  
     - **예: 특정 벤더의 장치에 대한 고유한 CPU 사용률 데이터**  
   - 일부 MIB는 **장치와 무관한 범용 데이터**를 제공합니다.  
     - **예: IP 데이터그램 헤더 오류로 인해 폐기된 IP 데이터그램 수, 호스트에서 수신한 UDP 세그먼트 수 등**  
   - 네트워크 운영자는 이 방법을 주로 **운영 상태를 조회하고 장치 통계를 모니터링하는 데 사용**하며, **장치를 제어하거나 구성할 때는 CLI를 함께 사용**하는 경우가 많습니다.  
   - 중요한 점은 **이 두 가지 방식(CLI 및 SNMP/MIB)은 개별 장치를 관리하는 방식**이라는 것입니다.  
   - 인터넷 아키텍처 위원회(IAB)가 2002년 개최한 네트워크 관리 워크숍 [RFC 3535]에서는 SNMP/MIB 방식이 **장치 모니터링에는 유용하지만, 대규모 네트워크 관리 및 장치 구성에는 한계가 있다**고 지적했습니다.  
   - 이러한 문제를 해결하기 위해 최근에는 **NETCONF 및 YANG 방식**이 등장했습니다.  

3. **NETCONF/YANG**  
   - NETCONF/YANG 접근 방식은 네트워크 관리에 대해 **보다 추상적이고 네트워크 전반을 고려하는 총체적(hollistic) 접근법**을 취합니다.  
   - 특히, **구성 관리(Configuration Management)**에 중점을 두며,  
     - **구성의 올바름 검증(Correctness Constraints) 지원**  
     - **여러 개의 장치를 대상으로 한 원자적(Atomic) 관리 작업 수행 가능**  
   - **YANG [RFC 6020]**:  
     - 네트워크 장치의 **구성 및 운영 데이터 모델링을 위한 데이터 모델링 언어**  
   - **NETCONF [RFC 6241]**:  
     - **YANG과 호환되는 데이터 및 작업을 원격 장치 간에 송수신하는 프로토콜**  
   - 우리는 OpenDaylight 컨트롤러 사례 연구(그림 5.17)에서 NETCONF와 YANG을 간략히 다뤘으며, 5.7.3절에서 더 자세히 살펴볼 것입니다.  

## 5.7.2 The Simple Network Management Protocol (SNMP) and the Management Information Base (MIB)
간단한 네트워크 관리 프로토콜 버전 3(SNMPv3) [RFC 3410]는 네트워크 관리 서버와 해당 서버를 대신하여 실행되는 에이전트 간에 네트워크 관리 제어 및 정보 메시지를 전달하는 애플리케이션 계층 프로토콜입니다. SNMP의 가장 일반적인 사용 방식은 요청-응답(request-response) 모드로, 여기서 SNMP 관리 서버가 SNMP 에이전트에게 요청을 보내면, 에이전트는 요청을 수신하고 특정 작업을 수행한 후 요청에 대한 응답을 보냅니다. 일반적으로 요청은 관리 대상 장치에 연결된 MIB 객체 값을 조회(검색)하거나 수정(설정)하는 데 사용됩니다.  

SNMP의 두 번째 일반적인 사용 방식은 **트랩(trap) 메시지**라고 알려진 **비동기적 메시지를 에이전트가 관리 서버에 보내는 것**입니다. 트랩 메시지는 링크 인터페이스의 활성화 또는 비활성화와 같은 예외적인 상황이 발생하여 MIB 객체 값이 변경되었음을 관리 서버에 알리는 데 사용됩니다.  

MIB 객체는 **SMI(Management Information Structure) [RFC 2578; RFC 2579; RFC 2580]**라고 알려진 데이터 기술 언어를 사용하여 지정됩니다. 이 용어는 기능과 관련이 없어 보이지만, 네트워크 관리 프레임워크의 중요한 구성 요소 중 하나입니다. 공식적인 정의 언어를 사용하여 네트워크 관리 데이터의 구문 및 의미론이 명확하고 모호하지 않도록 보장합니다. 관련된 MIB 객체들은 **MIB 모듈**로 그룹화됩니다. 2019년 말 기준으로, **400개 이상의 MIB 관련 RFC**가 존재하며, 이보다 훨씬 더 많은 벤더별(프라이빗) MIB 모듈이 존재합니다.  

### **SNMPv3에서 정의된 7가지 프로토콜 데이터 단위(PDU)**  

SNMPv3에서는 **프로토콜 데이터 단위(PDU)**라고 불리는 **7가지 유형의 메시지**가 정의됩니다. PDU의 형식은 그림 5.21에 나와 있습니다.  

- **GetRequest, GetNextRequest, GetBulkRequest PDU**  
  - 관리 서버에서 에이전트로 보내는 요청 메시지로, 에이전트가 관리하는 장치에서 **하나 이상의 MIB 객체 값을 요청**하는 데 사용됩니다.  
  - 요청된 MIB 객체 값은 PDU의 **변수 바인딩(variable binding) 부분**에 지정됩니다.  
  - 세 가지 요청은 요청 데이터의 세분성에서 차이가 있습니다.  
    - **GetRequest**: 임의의 MIB 값 집합을 요청할 수 있음.  
    - **GetNextRequest**: 여러 개의 GetNextRequest를 사용하여 **MIB 객체 목록 또는 테이블을 순차적으로 검색 가능**.  
    - **GetBulkRequest**: 대량 데이터를 한 번에 반환하여 **여러 개의 GetRequest 또는 GetNextRequest 메시지를 보내는 오버헤드를 방지**.  
  - 모든 경우에, 에이전트는 **Response PDU**를 사용하여 객체 식별자(OID)와 해당 값을 반환합니다.  

- **SetRequest PDU**  
  - 관리 서버에서 관리 장치의 **하나 이상의 MIB 객체 값을 설정(수정)**하는 데 사용됩니다.  
  - 에이전트는 "noError" 상태의 **Response PDU**를 반환하여 값이 정상적으로 설정되었음을 확인합니다.  

- **InformRequest PDU**  
  - 한 관리 서버가 **다른 관리 서버**에게 원격 MIB 정보를 알리는 데 사용됩니다.  

- **Response PDU**  
  - 관리 대상 장치에서 **관리 서버의 요청에 대한 응답**으로 전송되며, 요청된 정보를 반환합니다.  

- **Trap PDU (트랩 메시지)**  
  - 트랩 메시지는 **비동기적으로 생성**됩니다. 즉, 요청에 대한 응답으로 생성되는 것이 아니라, **예외적인 이벤트 발생 시 관리 서버에 알리는 역할**을 합니다.  
  - **RFC 3418**은 잘 알려진 트랩 유형을 정의하고 있으며, 여기에는 다음과 같은 이벤트가 포함됩니다.  
    - 장치의 **콜드 스타트(cold start)** 또는 **웜 스타트(warm start)**  
    - **링크가 활성화(up)되거나 비활성화(down)됨**  
    - **이웃 손실(neighbor loss)**  
    - **인증 실패(authentication failure)**  
  - 관리 서버는 수신된 트랩 요청에 대해 응답할 필요가 없습니다.  

### **SNMP의 요청-응답 모델 및 UDP 기반 통신**  

SNMP는 기본적으로 **요청-응답(request-response) 모델**을 따릅니다. SNMP PDU는 여러 전송 프로토콜을 통해 전송될 수 있지만, 일반적으로 **UDP 데이터그램의 페이로드**에 포함됩니다.  

RFC 3417은 **UDP가 SNMP의 "선호되는 전송 매핑(preferred transport mapping)"**임을 명시합니다. 그러나 UDP는 신뢰할 수 없는 전송 프로토콜이므로 **요청이나 응답이 의도한 목적지에 도달할 것이라는 보장이 없습니다**.  

- **PDU의 Request ID 필드**  
  - 관리 서버가 에이전트에게 요청을 보낼 때 **각 요청에 고유한 Request ID**를 부여합니다.  
  - 에이전트는 받은 요청의 Request ID를 **응답 PDU에도 동일하게 설정하여 반환**합니다.  
  - 이를 통해 관리 서버는 **손실된 요청이나 응답을 감지할 수 있습니다**.  

- **재전송 정책**  
  - SNMP 표준은 특정한 재전송 절차를 정의하지 않으며, **요청을 재전송할지 여부는 관리 서버의 결정에 달려 있습니다**.  
  - SNMP 표준에서는 단순히 관리 서버가 **"재전송 빈도 및 지속 시간에 대해 책임감 있게 행동해야 한다"**고 요구합니다.  
  - 그러나 **"책임감 있게"라는 기준이 무엇인지는 정의되지 않아, 실제 운영에서 구현 방식이 다양할 수 있습니다.**  

### **SNMP의 발전: SNMPv3의 보안 및 관리 기능**  

SNMP는 **세 가지 버전**을 거쳐 발전해 왔습니다.  

SNMPv3의 설계자는 SNMPv3를 **"SNMPv2에 보안 및 관리 기능을 추가한 것"**으로 간주합니다 [RFC 3410].  
- SNMPv3에서는 **관리 및 보안 측면이 가장 중요한 개선 사항**이었으며,  
- SNMP의 보안이 불충분했기 때문에 **SNMP가 주로 모니터링 용도로만 사용되고 제어(SetRequest)는 거의 사용되지 않았습니다**.  
- 보안 문제는 네트워크 관리에서 중요한 요소이며, 8장에서 보다 자세히 다룰 것입니다.  

---

### **관리 정보 베이스(MIB, Management Information Base)**  

이전에 배운 것처럼, SNMP/MIB 접근 방식에서 **관리 장치의 운영 상태 데이터(일부 구성 데이터 포함)는 MIB 객체로 표현됩니다**.  

- MIB 객체의 예시:  
  - **카운터 값**:  
    - 특정 라우터에서 **IP 데이터그램 헤더 오류로 인해 폐기된 데이터그램 수**  
    - 이더넷 인터페이스 카드에서 **캐리어 센스 오류(carrier sense errors) 수**  
  - **설명 정보**:  
    - DNS 서버에서 실행 중인 소프트웨어의 버전  
  - **상태 정보**:  
    - 특정 장치가 정상적으로 작동하는지 여부  
  - **프로토콜 정보**:  
    - 특정 목적지까지의 라우팅 경로  

관련 MIB 객체들은 **MIB 모듈**로 그룹화됩니다.  
- 400개 이상의 MIB 모듈이 다양한 IETF RFC에서 정의되었으며,  
- 벤더별 장치에 맞춘 **수많은 프라이빗 MIB 모듈**도 존재합니다.  
- [RFC 4293]은 IP 및 ICMP 프로토콜 관리를 위한 MIB 모듈을 정의합니다.  
- [RFC 4022]는 TCP, [RFC 4113]은 UDP에 대한 MIB 모듈을 정의합니다.  

다음은 **RFC 4293**에서 정의된 **ipSystemStatsInDelivers 객체**의 예제입니다.  
```plaintext
ipSystemStatsInDelivers OBJECT-TYPE  
 SYNTAX Counter32  
 MAX-ACCESS read-only  
 STATUS current  
 DESCRIPTION  
 “IP 사용자 프로토콜(예: ICMP)에 성공적으로 전달된 데이터그램 수”  
 ::= { ipSystemStatsEntry 18 }
```  
이 객체는 관리 장치에서 수신된 IP 데이터그램이 상위 계층 프로토콜로 성공적으로 전달된 횟수를 기록하는 32비트 카운터입니다.

## 5.7.3 The Network Configuration Protocol (NETCONF) and YANG
NETCONF 프로토콜은 **관리 서버(managing server)와 관리 대상 네트워크 장치(managed network devices) 간에 작동**하며, 다음과 같은 메시징 기능을 제공합니다.  
(i) **관리 대상 장치에서 구성 데이터를 검색, 설정 및 수정**  
(ii) **관리 대상 장치의 운영 데이터 및 통계를 조회**  
(iii) **관리 대상 장치에서 생성된 알림을 구독**  

관리 서버는 **구성(configuration)을 지정된 구조화된 XML 문서로 관리 대상 장치에 전송하고, 해당 장치에서 구성을 활성화함으로써 장치를 적극적으로 제어**합니다.  
NETCONF는 **원격 프로시저 호출(Remote Procedure Call, RPC) 패러다임**을 사용하며,  
프로토콜 메시지는 XML로 인코딩되어 **TLS(전송 계층 보안, Transport Layer Security) 프로토콜을 사용하는 TCP와 같은 보안, 연결 지향 세션**을 통해 관리 서버와 관리 대상 장치 간에 교환됩니다. (TLS에 대한 내용은 8장에서 다룹니다.)  

---

그림 5.22는 NETCONF 세션의 예를 보여줍니다.  
1. **관리 서버는 관리 대상 장치에 보안 연결을 설정합니다.**  
   - (NETCONF 용어에서는 **관리 서버를 "클라이언트(client)"**,  
   - **관리 대상 장치를 "서버(server)"**라고 부르는데,  
   - 이는 **관리 서버가 관리 대상 장치에 연결을 설정하기 때문**입니다.  
   - 하지만 본문에서는 그림 5.20의 기존 네트워크 관리 서버/클라이언트 용어와 일관성을 유지하기 위해 이를 무시하겠습니다.)  
2. **보안 연결이 설정된 후, 관리 서버와 관리 대상 장치는 `<hello>` 메시지를 교환합니다.**  
   - 여기서 **각 장치는 자신이 지원하는 NETCONF 기능(기본 NETCONF 사양 [RFC 6241]을 보완하는 기능)을 선언합니다.**  
3. **관리 서버와 관리 대상 장치 간의 상호작용은 원격 프로시저 호출(RPC) 방식으로 수행됩니다.**  
   - `<rpc>` 및 `<rpc-response>` 메시지를 사용하여 다음과 같은 작업을 수행합니다.  
     - 장치의 **구성(configuration) 조회, 설정, 수정**  
     - 장치의 **운영 데이터 및 통계 조회**  
     - 장치 알림 구독  
4. **장치 알림(device notifications)은 `<notification>` 메시지를 사용하여 관리 대상 장치에서 관리 서버로 **능동적으로 전송됩니다.**  
5. **세션이 종료될 때 `<session-close>` 메시지가 사용됩니다.**  

---

### **NETCONF의 주요 작업 (표 5.3 참고)**  

NETCONF는 **SNMP와 유사한 데이터 조회 및 이벤트 알림 기능**을 제공합니다.  
그러나 `<get-config>`, `<edit-config>`, `<lock>`, `<unlock>` 등의 작업은  
NETCONF가 **특히 장치 구성(configuration)에 초점을 맞춘다는 점을 보여줍니다.**  

NETCONF의 기본 작업(표 5.3 참조)을 사용하면,  
**다중 장치에서 원자적으로(atomic) 완료되거나 완전히 롤백되는 네트워크 관리 트랜잭션**을 생성할 수도 있습니다.  
즉, **"네트워크 운영자가 개별 장치가 아닌 네트워크 전체의 구성을 집중적으로 관리할 수 있도록 한다"**는 것이  
RFC 3535에서 제시된 중요한 운영자 요구 사항이었습니다.  

NETCONF의 전체 설명은 본문의 범위를 벗어나지만,  
더 깊이 있는 내용은 [RFC 6241, RFC 5277, Claise 2019; Schonwalder 2010]에서 확인할 수 있습니다.  

---

### **NETCONF의 XML 기반 메시지 예제**  

SNMP의 PDU(그림 5.21 참조)처럼 **헤더 필드와 메시지 본문으로 이루어진 전통적인 프로토콜 메시지 형식과 달리**,  
NETCONF에서는 **XML 문서 형식의 프로토콜 메시지**를 사용합니다.  
아래 두 가지 예제를 통해 이를 살펴보겠습니다.  

---

#### **첫 번째 예제: `<get>` 명령을 사용하여 장치의 모든 구성 및 운영 데이터 요청**  

아래 XML 문서는 **관리 서버에서 관리 대상 장치로 전송되는 `<get>` 명령**을 포함합니다.  
이를 통해 **서버는 장치의 전체 구성을 조회할 수 있습니다.**  

```xml
01 <?xml version="1.0" encoding="UTF-8"?>
02 <rpc message-id="101"
03 xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
04 <get/>
05 </rpc>
```

- **RPC 메시지(02~05줄)**  
  - 메시지 ID는 `101` (2번째 줄)  
  - `<get>` 명령 포함 (4번째 줄)  

- **관리 대상 장치의 응답**  
  - 응답 XML 문서는 **메시지 ID(101)를 유지**하며,  
  - 장치의 **모든 구성 데이터를 반환**합니다.  

```xml
01 <?xml version="1.0" encoding="UTF-8"?>
02 <rpc-reply message-id="101"
03 xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
04 <!-- . . . 모든 구성 데이터 반환 -->
. . .
</rpc-reply>
```

---

#### **두 번째 예제: `<edit-config>` 명령을 사용하여 MTU 값 변경**  

아래 XML 문서는 **관리 서버에서 관리 대상 장치로 전송되는 `<edit-config>` 명령**을 포함하며,  
**"Ethernet0/0" 인터페이스의 MTU 값을 1500 바이트로 설정**합니다.  

```xml
01 <?xml version="1.0" encoding="UTF-8"?>
02 <rpc message-id="101"
03 xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
04 <edit-config>
05 <target>
06 <running/>
07 </target>
08 <config>
09 <top xmlns="http://example.com/schema/1.2/config">
10 <interface>
11 <name>Ethernet0/0</name>
12 <mtu>1500</mtu>
13 </interface>
14 </top>
15 </config>
16 </edit-config>
17 </rpc>
```

- **RPC 메시지(02~17줄)**  
  - 메시지 ID는 `101` (2번째 줄)  
  - `<edit-config>` 명령 포함 (4번째 줄)  
  - **실행 중인 장치 구성(`running`)이 변경됨** (6번째 줄)  
  - **Ethernet0/0 인터페이스의 MTU 값이 1500으로 설정됨** (11~12번째 줄)  

- **관리 대상 장치의 응답**  
  - 장치는 **MTU 값을 성공적으로 변경한 후, `<ok>` 응답을 반환**합니다.  

```xml
01 <?xml version="1.0" encoding="UTF-8"?>
02 <rpc-reply message-id="101"
03 xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
04 <ok/>
05 </rpc-reply>
```

---

### **YANG**  

**YANG은 NETCONF에서 사용되는 네트워크 관리 데이터의 구조, 구문 및 의미를 명확하게 지정하는 데이터 모델링 언어입니다.**  
이는 SNMP에서 **SMI(Structure of Management Information)**를 사용하여 MIB를 정의하는 방식과 유사합니다.  

- **YANG 모듈(module)**:  
  - 모든 YANG 정의는 **모듈(module) 단위**로 포함됨.  
  - YANG 모듈을 사용하여 **장치 및 해당 기능을 설명하는 XML 문서 생성 가능**.  

- **YANG의 주요 기능**:  
  - **기본 데이터 유형(built-in data types) 제공**  
  - **유효한 NETCONF 구성이 만족해야 하는 제약 조건을 정의 가능**  
    - 이를 통해 **설정의 정확성과 일관성을 보장**하는 강력한 기능 제공  
  - **NETCONF 알림(notification) 정의**  

YANG에 대한 보다 자세한 논의는 본문의 범위를 벗어나므로,  
더 깊이 있는 내용은 [Claise 2019]에서 확인할 수 있습니다.  
